---
title: "MOCO_analysis"
author: "Yiming"
date: "`r Sys.time()`"
output: pdf_document
Description: this file indicates the statistical analysis of the MOCO projects (both children and adults)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lme4)
library(knitr)
library(psyphy)
library(sjPlot)
library(dplyr)
library(ggplot2)
# if (!("pacman" %in% installed.packages()[,])) {
#     install.packages("pacman")
#   }
# library(pacman)
# pacman::p_load(dplyr, ggplot2, knitr, psyphy, lme4, sjPlot)
```

```{r ggplot-themes}
theme.custom <- theme(plot.title = element_text(size=16, face="bold"),
                      axis.title.x = element_text(size=14),
                      axis.title.y = element_text(size=14),
                      strip.text = element_text(size=14),
                      axis.text = element_text(size=11),
                      legend.position="bottom", 
                      legend.title=element_blank(),
                      legend.text=element_text(size=11))
```

## Import aggregate data

Here we import the aggregate data file found in `analyses/data-aggregate/moco-beh-child.csv`, convert `AgeDays` to a categorical factor, `AgeYrs` (norminal) and 'Age' (ordinal), convert gender into 1 (female) and 2 (male). In this dataset, the NaN of Acc is fixed but the outliers are not cleaned up.

file.exists("analysis/data/child/data-aggregate/moco-beh-child.csv")

# load data
```{r load-files}
df_child <- read.csv(file = "~/Documents/github/moco-psychophysics-child-adult/analysis/data/child/data-aggregate/moco-beh-child.csv", header = TRUE)
df_adult <- read.csv(file = "~/Documents/github/moco-psychophysics-child-adult/analysis/data/moco-adult.csv", header = TRUE)
df_adult$Speed <- factor(df_adult$Speed, labels = c("2 deg/s", "8 deg/s"))
df_child$Speed <- factor(df_child$Speed, labels = c("2 deg/s", "8 deg/s"))
df_child$Age <- df_child$AgeDays/365.25
df_child$AgeYrs <- ordered(cut(df_child$AgeDays/365.25, 
                 breaks = c(5,6,7,8,9), 
                 labels = c("5 yrs", "6yrs", "7yrs", "8yrs")))
df_child <- df_child %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Age, AgeYrs)
df_adult <- df_adult %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Age)
df_all <- read.csv(file="~/Documents/github/moco-psychophysics-child-adult/analysis/CombinedData.csv", header=TRUE, sep=",")
#### 30 children and 29 adults, each has 320 data. But the first adult has 480 data.
```

## subject-level cleaning 
Let's check the plot of df2 for each subject by computing some summary statistics across trial and block. These summary values are saved to the  `df.bysub.bycond` data frame.
```{r summary-data}
# summary statistics of child data 
df_child %>% 
  group_by(Gender, SubID, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) -> 
  df_child.summary

# df_child.summary <- df_child.summary %>%
#   group_by(Coh) %>%
#   mutate(pcorr.mean=mean(Pct.Corr),
#          pcorr.sd=sd(Pct.Corr),
#          RT.mean.mean=mean(RT.mean),
#          RT.mean.sd=sd(RT.mean))
# pcorr.mean and RT.mean.mean is the mean of Coherence condition.

# summary statistics of df2 by condition
df_child %>% 
  group_by(SubID, Age, Gender, AgeYrs, PatternType, Speed, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) -> 
  df_child.bysub.bycond

df_child.bysub.bycond <- df_child.bysub.bycond %>%
  group_by(PatternType,Speed,Coh) %>%
  mutate(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean) )
# pcorr.mean and RT.mean.mean is the mean of three condition. It is for make plot.
```

```{r test-normality}
# the y axis represents the observations and the x axis represents the quantiles modeled by the distribution. The solid line represents a perfect distribution fit and the dashed lines are the confidence intervals of the perfect distribution fit
library(car)
qqp(df2$Acc,"norm")
# lognormal
qqp(df2$Acc,"lnorm")
# test normality of RT 
hist(df2$RT,breaks=100)
qqPlot(df2$RT)
qqnorm(df2$RT); qqline(df2$RT)
# lognormal
qqp(df2$RT,"lnorm")
df2 %>%         # From the output, the p-value > 0.05 implying that the distribution of the data are not significantly different from normal distribution. In other words, we can assume the normality.
  group_by(SubID) %>% 
  summarize(results = data_frame(shapiro.test(RT)))->shapiroresult  # the result show all subject do not have normal distribution of RT. the linear mixed-effect model do not require the normality. but the residual need to dit the normal distribution
# qqp requires estimates of the parameters of the negative binomial, Poisson
# and gamma distributions. You can generate estimates using the fitdistr
# function. Save the output and extract the estimates of each parameter as I
# have shown below.
library(MASS)
# you might actually have something that fits a specific non-linear model (hierarchical generalized linear model or generalized linear mixed model) which has a link function, such as a Poisson model or a negative binomial. 
nbinom <- fitdistr(c(na.exclude(df2$RT)), "Negative Binomial") 
qqp(na.exclude(df2$RT), "nbinom", size = nbinom$estimate[[1]], mu = nbinom$estimate[[2]])
#poisson <- fitdistr(recog$Aggression.t, "Poisson")
#qqp(recog$Aggression.t, "pois", poisson$estimate)   #for positive integer
gammad <- fitdistr(c(na.exclude(df2$RT)), "gamma")
qqp(na.exclude(df2$RT), "gamma", shape = gammad$estimate[[1]], rate = gammad$estimate[[2]])
```

### plot of *p*(Corr) by subj
```{r p-corr-subj-mean-plot}
# Plot theme, customizations 
y_lbl <- 'p(corr)'
title_text <- 'p(corr) by subj'

# lines for each subj
p1 <- ggplot(df.summary, aes(Coh, Pct.Corr)) +
   geom_line(aes(group=SubID, color=AgeYrs)) +
   labs(x="Coherence", y=y_lbl) +
   ggtitle(title_text) +
   theme_bw() +
   theme.custom +
   xlim(0, 1) +
   geom_hline(yintercept=0.5, linetype="dashed")

 sd = 3
 df.summary <- df.summary %>%
   group_by(Coh) %>%
   mutate(pcorr.lower_bound = pcorr.mean-sd*pcorr.sd,pcorr.upper_bound=pcorr.mean+sd*pcorr.sd)

#confidence band
p1 <- p1 +
   geom_line(aes(Coh, pcorr.mean), size = 2) +
   geom_ribbon(aes(ymin = pcorr.lower_bound, ymax =pcorr.upper_bound), fill = "grey70",
                 alpha=0.5)       #transparency

 p1
 # I can try geom_smooth function next time
# from the plot, we can see the accuracy of subj 1088 has below average percentage of accuracy. But it is not significant
```
 
### plot of RT by subj
```{r RT-subj-mean-plot}
# Plot theme, customizations
y_lbl <- 'RT'
title_text <- 'RT by subj'

# lines for each subj
p2 <- ggplot(df.summary, aes(Coh, RT.mean)) +
   geom_line(aes(group=SubID, color=AgeYrs)) +
   labs(x="Coherence", y=y_lbl) +
   ggtitle(title_text) +
   theme_bw() +
   theme.custom +
   xlim(0, 1) +
   geom_hline(yintercept=0.5, linetype="dashed")


sd = 3
df.summary <- df.summary %>%
   group_by(Coh) %>%
   mutate(RT.lower_bound = RT.mean.mean-sd*RT.mean.sd,RT.upper_bound=RT.mean.mean+sd*RT.mean.sd)

# confidence band
p2 <- p2 +
   geom_line(aes(Coh, RT.mean.mean), size = 2) +
   geom_ribbon(aes(ymin = RT.lower_bound, ymax =RT.upper_bound), fill = "grey70",
                 alpha=0.5)       #transparency

p2
```

### Plot of *p*(corr) by condition
```{r p-corr-pattern-speed-plot, include=TRUE}
y_lbl <- 'p(corr)'
title_text <- 'p(corr) by Coherence, Pattern, and Speed'
df.bysub.bycond$Speed <- factor(df.bysub.bycond$Speed, labels = c("2 deg/s", "8 deg/s"))

sd = 3
df.bysub.bycond <- df.bysub.bycond %>%
  group_by(PatternType, Speed,Coh) %>%
  mutate(lower_bound = pcorr.mean-sd*pcorr.sd,upper_bound=pcorr.mean+sd*pcorr.sd)
# Plot for all subs
p.corr <- ggplot(data=df.bysub.bycond, aes(x=Coh, y=Pct.Corr))
p.corr <- p.corr +
  geom_line(aes(group=SubID, color=AgeYrs)) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence", y=y_lbl) +
  ggtitle(title_text) +
  theme_bw() +
  theme.custom +
  xlim(0, 1) +
  geom_hline(yintercept=0.5, linetype="dashed")
# confidence band
p.corr <- p.corr +
  geom_line(aes(Coh, pcorr.mean), size = 2) +
  geom_ribbon(aes(ymin = lower_bound, ymax =upper_bound), fill = "grey70",
                alpha=0.5)
p.corr
# we can see the small variance at the coherence level of .20, .40, .80 for small sample size. In radial condition, one subj (1088) is deviant in speed of 2 deg/s and 1059 is deviant in speed of 8 deg/s.
```

### Plot of RT by condition
```{r rt-pattern-speed-plot, include=TRUE}
# Plot RTs
y_lbl <- 'RT (s)'
title_text <- 'RT by Coherence, Pattern, and Speed'

sd = 3
df.bysub.bycond <- df.bysub.bycond %>%
  group_by(PatternType, Speed,Coh) %>%
  mutate(lower_bound = RT.mean.mean-sd*RT.mean.sd,upper_bound=RT.mean.mean+sd*RT.mean.sd)

# Plot for all subs
p.rt <- ggplot(data=df.bysub.bycond, aes(x=Coh, y=RT.mean))
p.rt <- p.rt +
  geom_line(aes(group=SubID, color=AgeYrs)) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence", y=y_lbl) +
  # ggtitle(title_text) +
  theme_bw() +
  theme.custom +
  xlim(0, 1)
# confidence band
p.rt <- p.rt +
  geom_line(aes(Coh, RT.mean.mean), size = 2) +
  geom_ribbon(aes(ymin = lower_bound, ymax =upper_bound), fill = "grey70",
                alpha=0.5)
p.rt
# In condition of speed of 2, there are 2 deviance (one subj 1077 deviant from the mean in both linear condition and radial condition)
```
#Generalized linear mixed effects model with a probit link/ logit link/ weibull model
Generalized linear mixed effects model 
The level 1 (i) is accuracy/RT in each condition for each subject. The level 2 (j) is each subject. The random effects in this model are SubID, Gender and AgeYrs. Fixed effects are Speed, PatternType, Coh, and their interaction
$Y_{i,j}=B_{0j} + B_{1j}*PatternType_{ij}+B_{2j}*Speed_{ij}+B_{3j}*Coh_{ij}+e_{ij}$
$B_{0,j} = r_{00}+ r_{01}*Age_{j}+r_{02}*Gender_{j}+u_{0j}$
$B_{1,j} = r_{10}+u_{1j}$
$B_{2j} = r_{20}+u_{2j}$
$B_{3j} = r_{30}+u_{3j}$

## Accuracy 
df_child$Speed <- factor(df_child$Speed, labels = c("2 deg/s", "8 deg/s"))
df_child$SubID <- factor(df_child$SubID)
Rescale and center continuous parameters
df_child$Coh_scaled<- scale(df_child[,7])
df_child$Age_scaled<- scale(df_child[,8])
df2$AgeYrs <- factor(df2$AgeYrs,ordered = FALSE) # the variables can not be ordinal, it will have L, C, Q
### probit link function
#### Empty model
```{r acc-probit-empty, eval=FALSE}
form.empty <- Acc~(1|SubID)
model.acc.empty <- glmer(formula = form.empty, family=binomial(mafc.probit(2)), data = df_child)
summary(model.acc.empty)
```

```{r ICC-Acc, eval=FALSE}
ICC_Acc <- 0.1289/(0.1289+0.8074)
# The result is the same as the uncleaned one
```
ICC is small (14%)
#### full model with random intercept
```{r acc-probit-without-Gender-Age, eval=FALSE}
form.fixed <- Acc ~ Coh + Speed + PatternType  + (1|SubID)
model.acc.fixed <- glmer(formula = form.fixed, family=binomial(mafc.probit(2)), data = df_child)
summary(model.acc.fixed)
```
AIC 5753

#### full model with random intercept and random slope
```{r acc-probit-random-slope-gender, eval=FALSE}
model.gender<- Acc ~ Coh + Speed + PatternType + (1+Gender|SubID)
model.acc.gender<- glmer(formula = model.gender, family=binomial(mafc.probit(2)),  glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),data = df_child)
summary(model.acc.gender)
```

AIC 5757
```{r acc-probit-random-slope-AgeYrs, eval=FALSE}
form.age <- Acc ~ Coh + Speed + PatternType + (Age+1|SubID)
model.acc.age <- glmer(formula = form.age, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),data = df_child)
summary(model.acc.age)
```

AIC 5755
AIC does not decrease in the random slope model

#### age and gender as fixed effect
```{r acc-probit-without-gender, eval=FALSE}
form.fixed1 <- Acc ~ Coh + Speed + PatternType + Age + (1|SubID)
model.acc.fixed1 <- glmer(formula = form.fixed1, family=binomial(mafc.probit(2)),  data = df_child)
summary(model.acc.fixed1)
library(lmtest)
lrtest(model.acc.fixed,model.acc.fixed1) # likelihood test: not significant
# wardtest(model.acc.fixed,model.acc.fixed1)
anova(model.acc.fixed,model.acc.fixed1)  # waldtest: significant
```
AIC 5732

```{r acc-probit-without-age, eval=FALSE}
form.fixed2 <- Acc ~ Coh + Speed + PatternType + Gender + (1|SubID)
model.acc.fixed2 <- glmer(formula = form.fixed2, family=binomial(mafc.probit(2)), data = df2)
summary(model.acc.fixed2)
anova(model.acc.fixed,model.acc.fixed2) #significant
```
AIC 5748
```{r acc-probit-full, eval=FALSE}
form.full <- Acc ~ scale(Coh) + Speed + PatternType + Gender + scale(Age) + (1|SubID)
model.acc.full <- glmer(formula = form.full, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.full)
anova(model.acc.fixed,model.acc.full)  # significant
```
#### interaction effect
```{r acc-probit-interaction, eval=FALSE}
form.full1<- Acc ~  scale(Age) + Gender + scale(Coh)*Speed*PatternType + (1|SubID)
model.acc.full1 <- glmer(formula = form.full1, family=binomial(mafc.probit(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), , data = df_child)
summary(model.acc.full1)
anova(model.acc.full1,model.acc.full)  #better fit
```
```{r acc-probit-interaction-gender-age, eval=FALSE}
form.full2<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + scale(Age)*scale(Coh) +scale(Age)*Speed + scale(Age)*PatternType+scale(Age)*Gender+Gender*scale(Coh) + Gender*Speed + Gender*PatternType+ (1|SubID)
model.acc.full2 <- glmer(formula = form.full2, family=binomial(mafc.probit(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.full2)
anova(model.acc.full1,model.acc.full2)  # better fit
## scale(Coh)*Speed , scale(Age)*scale(Coh) is significnant
```
# ##### bumped up max number of iterations.
#  ss <- getME(model.acc.full,c("theta","fixef"))
# <!-- m2 <- update(model.acc.full,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4))) -->
# still failed,  Try a different optimizer
# 
# ```{r find-optimizer}
# model.acc.full.new <- update(model.acc.full,start=ss,control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# summary(model.acc.full.new)

```{r acc-probit-full, eval=FALSE}
form.full3<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed  + (1|SubID) #Age*Coh design related
model.acc.full3 <- glmer(formula = form.full3, family=binomial(mafc.probit(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.full3)
anova(model.acc.full2,model.acc.full3)  # better fit
## scale(Coh)*Speed , scale(Age)*scale(Coh) is significnant
```
### logit link function
```{r acc-logit-interaction, eval=FALSE}
form.acc.logit<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + (1|SubID) #Age*Coh design related
model.acc.logit <- glmer(formula = form.acc.logit, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.logit)
anova(model.acc.logit,model.acc.full3) 
# ss <- getME(model.cloglog.interaction,c("theta","fixef"))
# m2 <- update(model.cloglog.interaction,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4)))
```

```{r get-coefficient-child}
# get coefficient
str(df_child)
form.acc.logit2<- Acc ~ Coh + Speed + PatternType + Age + Gender + Coh*Speed + (1|SubID) #Age*Coh design related
model.acc.logit2 <- glmer(formula = form.acc.logit2, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.logit2)
anova(model.acc.logit2)
lmerTest::anova(model.acc.logit2)
car::Anova(model.acc.logit2)  # this is betterm because F is said not work in glmer model
car::Anova(model.acc.logit) # there is slight difference between scaled and unscaled
afex::mixed(Acc ~ Coh + Speed + PatternType + Age + Gender + Coh*Speed + (1|SubID),family=binomial, data=df_child, method = "PB")
afex::mixed(Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + (1|SubID),family=binomial, data=df_child, method = "PB")
## the same 
# anova(model.acc.logit2,test="F")
## Type I Analysis of Variance Table with Satterthwaite's method
# anova(model.acc.logit2, type=1)
```

```{r get-df}
# get df. One way afex does not work for glmer, try lmer to get df, which should be the same as the glmer
model.acc.logit_lmer <- lmer(formula = form.acc.logit2,  data = df_child)
summary(model.acc.logit_lmer)
anova(model.acc.logit_lmer)
```

```{r get-95%CI&OR-child}
# Way 1
se <- sqrt(diag(vcov(model.acc.logit2)))
# table of estimates with 95% CI
tab <- cbind(OR = fixef(model.acc.logit2), LL = fixef(model.acc.logit2) - 1.96 * se, UL = fixef(model.acc.logit2) + 1.96 * se)
# however, this result is different from the below
print(exp(tab), digits=3)

# way 2
cc <- confint(model.acc.logit2)  ## slow (~ 11 seconds)
cc2 <- confint(model.acc.logit)  # test whether diff between scaled and unscaled
# get oR and 95% CI
ctab <- cbind(OR=fixef(model.acc.logit2),cc)
# Exponentiate to get odds ratios:
rtab <- exp(ctab)
print(rtab,digits=3)
# 2 way is slightly different

# way 3
profile.merMod 
confint.merMod

## Further explanation of confint
### obtain confidence intervals for the coefficient estimates
confint(model.acc.logit2) 
# get the exact 95% confidence interval for the coefficients b
exp(confint(model.acc.logit2))
## use the parametric bootstrap to calculate confidence intervals
confint(model.acc.logit2, method="boot", nsim=1000, parm=1:3)
```
<!-- wald.test(b = coef(model.logit.interaction), Sigma = vcov(model.logit.interaction), Terms = 4:6) -->
AIC 5715, smaller AIC

``` {r acc-post-hoc}
# contrast within factor: pairwise comparison
# emeans cannot be installed in this r version
# check https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/
library(emmeans)
emmeans(model.acc.logit2, Acc ~ gender)
emm1.1<-emmeans(fit1, specs = pairwise ~ f1:f2, type = "response", adjust = "none")
emm1.1$contrasts %>%
     confint()
emm2 = emmeans(fit1, specs = pairwise ~ f1|f2, type = "response")
emm2

# way 1
library(multcomp)
summary(glht(model.acc.logit2, mcp(Gender="Tukey")))
summary(glht(model.acc.logit2, mcp(Coh="Tukey")))
```

```{r acc-cloglog-interaction, eval=FALSE}
# Can fit a Weibull function, but use log contrast as variable 
# see http://finzi.psych.upenn.edu/library/psyphy/html/mafc.html

form.acc.cloglog<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + (1|SubID)
model.acc.cloglog <- glmer(formula = form.acc.cloglog, family=binomial(mafc.cloglog(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),  data = df_child)
summary(model.acc.cloglog)
anova(model.acc.logit,model.acc.cloglog) 
anova(model.acc.cloglog,model.acc.full3) 
# ss <- getME(model.cloglog.interaction,c("theta","fixef"))
# m3 <- update(model.cloglog.interaction,start=ss,control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# summary(m3)

# Weibull parameters \alpha and \beta
cc <- coef(model.acc.cloglog)
alph <- exp(-cc[1]/cc[2])
bet <- cc[2]
```
AIC 5768

### Weibull function
```{r weibull-interaction, eval=FALSE}
library(psyphy)
form.acc.weibull<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + (1|SubID)
model.acc.weibull <- glmer(formula = form.acc.weibull, family=binomial(mafc.weib(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),  data = df_child)
summary(model.acc.weibull)
```
AIC 5734
accfit <- fitdist(df.bysub.bycond$Pct.Corr,"weibull") # by conditions?
accfit   # estimate
weibull(,shape=9.3969663,scale=0.9412456)

# library(VGAM)
# form.weibull.interaction<- Acc ~ Coh + Speed + PatternType + Coh*Speed*PatternType + (1|SubID)
# model.weibull.interaction <- vglm(formula = form.weibull.interaction, family = weibull(link='log'), data = df)
# summary(model.weibull.interaction)



<!-- ### wald test -->
<!-- ```{r comparsion} -->
<!-- #### compare two models -->
<!-- waldtest(model.acc.logit,model.acc.probit)  -->
<!-- #### post hoc -->
<!-- anova(model.acc.logit)    # a wald test for the fixed effects -->
<!-- wald.test(b = coef(model.acc.logit), Sigma = vcov(model.acc.logit), Terms = 2) <!-- #test Coh --> -->
<!-- wald.test(b = coef(model.acc.logit), Sigma = vcov(model.acc.logit), Terms = 3) <!-- #test Speed --> -->
<!-- wald.test(b = coef(model.acc.logit), Sigma = vcov(model.acc.logit), Terms = 4) <!-- #test Pattern --> -->
<!-- wald.test(b = coef(model.acc.logit), Sigma = vcov(model.acc.logit), Terms = 5) <!-- #test Coh::Speed --> -->
<!-- <!-- l <- cbind(0, 0, 0, 1, -1, 0) -->
<!-- wald.test(b = coef(myprobit), Sigma = vcov(myprobit), L = l) --> -->
<!-- ``` -->

<!-- ```{r correct response by log of Coh, Speed, PatternType} -->
<!-- df2$accfit <- fitted(model.acc.logit)  # shall I include the age and gender? -->
<!-- df2 %>%  -->
<!--   group_by(Age, PatternType, Speed, Coh) %>%  -->
<!--   summarize(N.corr = sum(Acc),  -->
<!--             N.tot = n(),  -->
<!--             Pct.Corr = N.corr/N.tot, -->
<!--             RT.mean=mean(RT, na.rm = T), -->
<!--             RT.sd=sd(RT, na.rm = T)) ->  -->
<!--   df.bycond -->

<!-- library(lattice) -->
<!-- xyplot(Pct.Corr~ Coh | Speed * PatternType, data = df.bycond, -->
<!-- 	subscripts = TRUE,  -->
<!-- 	# ID = with(ecc2, Size + as.numeric(task)), -->
<!-- 	scale = list(x = list(log = TRUE),  -->
<!-- 				 y = list(limits = c(0, 1))), -->
<!-- 	xlab = "Coherence", ylab = "Proportion Correct Response", -->
<!-- 	aspect = "xy", -->
<!-- 	panel = function(x, y, subscripts, ID, ...) { -->
<!-- 		which = unique(ID[subscripts]) -->
<!-- 		llines(x, ecc2$fit[which ==ID], col = "black", ...) -->
<!-- 		panel.xyplot(x, y, pch = 16, ...) -->
<!-- 		panel.abline(h = 0.25, lty = 2, ...) -->
<!-- 		} -->
<!-- ) -->
<!-- ``` -->

<!-- ```{r Acc-coef-plot1, include=TRUE} -->
<!-- ### obtain confidence intervals for the coefficient estimates -->
<!-- confint(model.acc.logit)  -->
<!-- # get the exact 95% confidence interval for the coefficients b -->
<!-- exp(confint(model.logit.interaction)) -->
<!-- #ranef(model.full,confVar=T) -->
<!-- #A generic function to extract the conditional modes of the random effects from a fitted model object. -->
<!-- #coef(model.full) -->
<!-- #coef is a generic function which extracts model coefficients from objects returned by modeling functions. coefficients is an alias for it. -->
<!-- hist(ranef(m3)$SubID[1:30,],xlab="U0j",main="Histogram of random effects") -->
<!-- hist(coef(m3)$SubID[1:30,1],xlab="Random intercepts",main="Histogram of random intercepts") -->
<!-- ``` -->

<!-- ```{r subject-specific-regression-plot1} -->
<!-- #plot lines for the first 5 schools based on the posterior means (M3) -->
<!-- plot(x=c(0,1),y=c(0,1),type="n",xlab="fixed effects",ylab="Acc",main="Subject-specific regression lines, m3") -->
<!-- for(i in 1:30) { -->
<!-- abline(a=coef(model.acc.logit)$SubID[i,1],b=coef(model.acc.logit)$SubID[i,2]) -->
<!-- } -->
<!-- ``` -->
<!-- ### make prediction -->
<!-- ```{r acc-prediction-plot} -->
<!-- prediction.acc <- data.frame(SubID = foo[["names"]],Coh = rep(seq(from = 15, to = 80, length.out = 100),  -->
<!--     2 * 2 * 30), Speed = factor(rep(c(2, 8), each = 100*30)), PatternType = factor(rep(c('linear','radial'), each=100*30))) -->
<!-- prediction.acc[, c("pcorr", "se")] <- predict(model.acc.logit, prediction.acc, type = "response", se.fit = TRUE)[-3] -->
<!-- ggplot(prediction.acc, aes(x = Coh, y = pcorr, colour = Age)) + geom_line() + facet_grid(facets = Speed ~ PatternType)  + theme_bw() + theme.custom  -->
<!-- # add age -->
<!-- ``` -->
<!-- library(car -->
<!-- car::outliers<-outlierTest(model.acc.logit, cutoff=0.05, n.max=30, order=TRUE, labels=names(rstudent), ...) -->

<!-- # Reports the Bonferroni p-values for testing each observation in turn to be a mean-shift outliner, based Studentized residuals in linear (t-tests) and generalized linear models (normal tests). -->


<!-- odd<-predict(model.logit.interaction,data.frame(Acc=c(, , ,))) -->
<!-- log_odds<-predict(model.logit.interaction,data.frame(b0*Coh + Speed + PatternType + Coh*Speed*PatternType)=c(0.25,0.5,0.75))) -->
<!-- exp(lodds)/(1+exp(lodds)) -->

### plotting

#### Plot of comparison of link functions
```{r p-corr-by-link-function}
# Evaluate Speed by Coherence interaction
y_mean <- df_child.summary %>%
  group_by(Coh) %>%
  summarize(Pct.Corr.mean = mean(Pct.Corr, na.rm=TRUE))
      #      Pct.Corr.sem = sd(Pct.Corr, na.rm=TRUE)/sqrt( n() ))
# limits = aes( ymax = Pct.Corr.mean + Pct.Corr.sem , ymin = Pct.Corr.mean - Pct.Corr.sem )
x <- seq(0, 0.8, 0.01)
data.frame(Coh=x, y_probit,y_logit,y_weibull)
y_probit <- predict(model.acc.full3, list(Coh = x), type = "response")
y_logit <- predict(model.acc.logit, list(Coh = x), type = "response")
y_weibull <- predict(model.acc.cloglog, list(Coh = x), type = "response")

p <- 
  ggplot( data=spd, aes(x=Coh, y=Pct.Corr.mean) ) +
  geom_line() +
  # geom_pointrange( limits ) +
  xlim(0,1) +
  ylim(.6, 1) +
  ylab("p(corr)") +
  xlab("Coherence)") +
  theme_bw() +
  theme.custom +
# geom_hline(yintercept=0.5, linetype="dashed")
  geom_line(data = y_probit, aes(x = dates, y = Difference), color = "blue") +
p

lines(x, y_probit, lwd = 1.5, col = "steelblue",, lty = 2)
lines(x, y_logit, lwd = 1.5, col = "green", lty = 2)
lines(x, y_logit, lwd = 1.5, col = "red", lty = 2)

# add a legend
legend("topleft",
       horiz = TRUE,
       legend = c("Probit", "Logit","Weibull"),
       col = c("steelblue", "green","red"), 
       lty = c(1, 2))
```
#### Plot of speed across patterns by age
```{r p-corr-by-speed-and-age-plot}
# Evaluate Speed by Coherence interaction
spd.by.coh <- df.bysub.bycond %>%
  group_by(Speed, Coh, AgeYrs) %>%
  summarize(Pct.Corr.mean = mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.sem = sd(Pct.Corr, na.rm=TRUE)/sqrt( n() ))

limits = aes( ymax = Pct.Corr.mean + Pct.Corr.sem , ymin = Pct.Corr.mean - Pct.Corr.sem )

p6 <- 
  ggplot( data=spd.by.coh, aes(x=Coh, y=Pct.Corr.mean, color = AgeYrs) ) +
  facet_grid( facets = . ~ Speed ) +
  geom_line() +
  geom_pointrange( limits ) +
  xlim(0,1) +
  ylim(.4, 1) +
  ylab("p(corr)") +
  xlab("Coherence)") +
  theme_bw() +
  theme.custom +
  geom_hline(yintercept=0.5, linetype="dashed")
p6
```

# Plot of coherence by pattern across age
```{r p-corr-by-pattern-and-age-plot, include=TRUE}
patt.by.coh <- df.bysub.bycond %>%
  group_by(PatternType, Coh, AgeYrs) %>%
  summarize(Pct.Corr.mean = mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.sem = sd(Pct.Corr, na.rm=TRUE)/sqrt( n() ))

limits = aes( ymax = Pct.Corr.mean + Pct.Corr.sem , ymin = Pct.Corr.mean - Pct.Corr.sem )

p7 <- 
  ggplot( data=patt.by.coh, aes(x=Coh, y=Pct.Corr.mean, color = AgeYrs) ) +
  facet_grid( facets = ~ PatternType ) +
  geom_line() +
  geom_pointrange( limits ) +
  xlim(0, 1) +
  ylim(.4, 1) +
  ylab("p(corr)") +
  xlab("Coherence)") +
  theme_bw() +
  theme.custom +
  geom_hline(yintercept=0.5, linetype="dashed")
p7
```















# adult data
### it is the data exclude subj 14
### plot of *p*(Corr) by subj
```{r p-corr-subj-mean-plot}
# Plot theme, customizations 
y_lbl <- 'p(corr)'
title_text <- 'p(corr) by subj'

# lines for each subj
p1 <- ggplot(df.summary, aes(Coh, Pct.Corr)) +
   geom_line(aes(group=SubID, color=Age)) +
   labs(x="Coherence", y=y_lbl) +
   ggtitle(title_text) +
   theme_bw() +
   theme.custom +
   xlim(0.05, 0.2) +
   geom_hline(yintercept=0.5, linetype="dashed")

 sd = 3
 df.summary <- df.summary %>%
   group_by(Coh) %>%
   mutate(pcorr.lower_bound = pcorr.mean-sd*pcorr.sd,pcorr.upper_bound=pcorr.mean+sd*pcorr.sd)

#confidence band
p1 <- p1 +
   geom_line(aes(Coh, pcorr.mean), size = 2) +
   geom_ribbon(aes(ymin = pcorr.lower_bound, ymax =pcorr.upper_bound), fill = "grey70",
                 alpha=0.5)       #transparency

 p1
 # I can try geom_smooth function next time
# from the plot, we can see the accuracy of subj 1088 has below average percentage of accuracy. But it is not significant
```

```{r exclude-outlier-subject}
# summary statistics of df2 by condition
df_adult %>% 
  group_by(Gender, Age, SubID, PatternType, Speed, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) -> 
  df_adult.bysub.bycond
df_adult.bysub.bycond <- df_adult.bysub.bycond %>%
  group_by(PatternType,Speed,Coh) %>%
  mutate(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean) )
```

### Plot of *p*(corr) by condition
```{r p-corr-pattern-speed-plot, include=TRUE}
title_text <- 'p(corr) by Coherence, Pattern, and Speed'
df.bysub.bycond$Speed <- factor(df.bysub.bycond$Speed, labels = c("2 deg/s", "8 deg/s"))

sd = 3
df.bysub.bycond <- df.bysub.bycond %>%
  group_by(PatternType, Speed,Coh) %>%
  mutate(lower_bound = pcorr.mean-sd*pcorr.sd,upper_bound=pcorr.mean+sd*pcorr.sd)
# Plot for all subs
p.corr <- ggplot(data=df.bysub.bycond, aes(x=Coh, y=Pct.Corr))
p.corr <- p.corr +
  geom_line(aes(group=SubID, color=Age)) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence", y=y_lbl) +
  ggtitle(title_text) +
  theme_bw() +
  theme.custom +
  xlim(0.05, 0.2) +
  geom_hline(yintercept=0.5, linetype="dashed")
# confidence band
p.corr <- p.corr +
  geom_line(aes(Coh, pcorr.mean), size = 2) +
  geom_ribbon(aes(ymin = lower_bound, ymax =upper_bound), fill = "grey70",
                alpha=0.5)
p.corr
```

#Generalized linear mixed effects model with a probit link/ logit link/ weibull model
Generalized linear mixed effects model 
The level 1 (i) is accuracy/RT in each condition for each subject. The level 2 (j) is each subject. The random effects in this model are SubID, Gender and AgeYrs. Fixed effects are Speed, PatternType, Coh, and their interaction
$Y_{i,j}=B_{0j} + B_{1j}*PatternType_{ij}+B_{2j}*Speed_{ij}+B_{3j}*Coh_{ij}+e_{ij}$
$B_{0,j} = r_{00}+ r_{01}*AgeYrs_{j}+r_{02}*Gender_{j}+u_{0j}$
$B_{1,j} = r_{10}+u_{1j}$
$B_{2j} = r_{20}+u_{2j}$
$B_{3j} = r_{30}+u_{3j}$

## Accuracy 
df_adult$Speed <- factor(df_adult$Speed, labels = c("2 deg/s", "8 deg/s"))
df_adult$SubID <- factor(df_adult$SubID)
Rescale and center continuous parameters
df_adult$Coh_scaled<- scale(df_adult[,7])
df_adult$Age_scaled<- scale(df_adult[,8])

df2$Age <- factor(df2$Age,ordered = FALSE) # the variables can not be ordinal, it will have L, C, Q
### probit link function
#### Empty model
```{r acc-probit-empty, eval=FALSE}
form.empty <- Acc~(1|SubID)
model.acc.empty <- glmer(formula = form.empty, family=binomial(mafc.probit(2)), data = df_adult)
summary(model.acc.empty)
```

```{r ICC-Acc, eval=FALSE}
ICC_Acc <-
The result is the same as the uncleaned one

```
ICC is small (14%)
#### full model with random intercept
```{r acc-probit-without-Gender-Age, eval=FALSE}
form.fixed <- Acc ~ Coh + Speed + PatternType  + (1|SubID)
model.acc.fixed <- glmer(formula = form.fixed, family=binomial(mafc.probit(2)), data = df_adult)
summary(model.acc.fixed) # AIC 9434
```

#### full model with random intercept and random slope
```{r acc-probit-random-slope-gender, eval=FALSE}
form.gender<- Acc ~ Coh + Speed + PatternType + (Gender|SubID)
model.acc.gender<- glmer(formula = form.gender, family=binomial(mafc.probit(2)), data = df2,
                         control=glmerControl(optimizer="bobyqa",
                          optCtrl=list(maxfun=1000000)) ) #AIC 9429
anova(model.acc.gender,model.acc.fixed)   # better fit
form.age <- Acc ~ Coh + Speed + PatternType + (Age|SubID)
model.acc.age <- glmer(formula = form.age, family=binomial(mafc.probit(2)), data = df2) #AIC 
form.coh<- Acc ~ Coh + Speed + PatternType + (Coh|SubID)
model.acc.coh<- glmer(formula = form.coh, family=binomial(mafc.probit(2)), data = df2 ) #AIC 9424 better fit
form.speed <- Acc ~ Coh + Speed + PatternType + (Speed|SubID)
model.acc.speed <- glmer(formula = form.speed, family=binomial(mafc.probit(2)), data = df2) #AIC 9338, better fit
form.pattern <- Acc ~ Coh + Speed + PatternType + (PatternType|SubID)
model.acc.pattern <- glmer(formula = form.pattern, family=binomial(mafc.probit(2)), data = df2) #AIC 9395.5, better fit
anova(model.acc.fixed,model.acc.coh)
anova(model.acc.fixed,model.acc.speed)
anova(model.acc.fixed,model.acc.pattern)
```
AIC does not decrease in the random slope model of age and 

####  gender as fixed effect
```{r acc-probit-full, eval=FALSE}
form_a.full <- Acc ~ Coh + Speed + PatternType + Gender + (1|SubID)
model_a.acc.full <- glmer(formula = form_a.full, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_adult)
summary(model_a.acc.full) # AIC 9414
anova(model_a.acc.fixed,model.acc.full)  # significant
anova(model_a.acc.full)
```
#### interaction effect
```{r acc-probit-interaction, eval=FALSE}
form_a.full1<- Acc ~  Gender+scale(Coh)+Speed+PatternType + scale(Coh)*Speed*PatternType + (1|SubID)
model_a.acc.full1 <- glmer(formula = form_a.full1, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 200000)),  data = df_adult)
summary(model_a.acc.full1)
 # AIC 9351.8
# Model failed to converge
```

```{r acc-probit-interaction-gender-age, eval=FALSE}
form_a.full3<- Acc ~ scale(Coh) + Speed + PatternType + Gender + scale(Coh)*Speed + scale(Coh)*PatternType + Gender*scale(Coh) + Gender*Speed + Gender*PatternType+ (1|SubID)
model_a.acc.full3 <- glmer(formula = form_a.full3, family=binomial(mafc.probit(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),  data = df_adult) # AIC 9359.9
summary(model_a.acc.full3)
```
```{r acc-probit-interaction-gender-coh, eval=FALSE}
form_a.probit<- Acc ~ scale(Coh) + PatternType + Speed + PatternType*scale(Coh) + Gender*Speed + Gender*PatternType+ (1|SubID)
model_a.acc.probit <- glmer(formula = form_a.probit, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),  data = df_adult)
summary(model_a.acc.probit)
anova(model_a.acc.full3,model_a.acc.probit)  # 9356.9, better fit
```
# ##### bumped up max number of iterations.
#  ss <- getME(model.acc.full,c("theta","fixef"))
# <!-- m2 <- update(model.acc.full,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4))) -->
# still failed,  Try a different optimizer
# 
# ```{r find-optimizer}
# model.acc.full.new <- update(model.acc.full,start=ss,control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# summary(model.acc.full.new)

### logit link function
```{r acc-logit-interaction, eval=FALSE}
model_a.acc.logit <- glmer(formula = form_a.probit, family=binomial(mafc.logit(2)), data = df_adult)
summary(model_a.acc.logit) # better fit than probit
car::Anova(model_a.acc.logit)
anova(model_a.acc.logit,model_a.acc.probit)
# ss <- getME(model.cloglog.interaction,c("theta","fixef"))
# m2 <- update(model.cloglog.interaction,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4)))
```
lmerTest::anova(model_a.acc.logit2)
MuMIn::r.squaredGLMM(model.acc.logit2) # ICC?
MuMIn::r.squaredLR(model.acc.logit2)
MuMIn::r.squaredLR(model.acc.logit2,null.RE = TRUE) 
# (R2m <- Vf / (Vtotal))
# (R2c <- (Vf + Vr) / (Vtotal))
effsize::cohen.d(df2$Acc ~ Gender+ Coh + Speed + PatternType + Coh*Speed + +Age*Speed + Age*PatternType + (1|SubID))
aod::wald.test(b = coef(model.acc.logit), Sigma = vcov(model.logit.interaction), Terms = 4:6)
pbkrtest::KRmodcomp(model_a.acc.logit2)


```{r get-df}
# get df. One way afex does not work for glmer, try lmer to get df, which should be the same as the glmer
model_a.acc.logit_lmer <- lmer(formula = model_a.acc.logit,  data = df_adult)
summary(model_a.acc.logit_lmer)
anova(model_a.acc.logit_lmer)
```

```{r get-95%CI&OR-child}
# Way 1
se <- sqrt(diag(vcov(model_a.acc.logit)))
# table of estimates with 95% CI
tab <- cbind(OR = fixef(model.acc.logit), LL = fixef(model.acc.logit2) - 1.96 * se, UL = fixef(model.acc.logit) + 1.96 * se)
# however, this result is different from the below
print(exp(tab), digits=3)

# way 2
cc_a <- confint(model_a.acc.logit)  ## slow (~ 11 seconds)
# get oR and 95% CI
ctab_a <- cbind(OR=fixef(model_a.acc.logit),cc_a)
# Exponentiate to get odds ratios:
rtab_a <- exp(ctab_a)
print(rtab_a,digits=5)
# if with scale
# sd of coh

sd<-sd(df_adult$Coh)
ctab_a <- cbind(OR=fixef(model_a.acc.logit)/sd,cc_a/sd)
# Exponentiate to get odds ratios:
rtab_a <- exp(ctab_a)
print(rtab_a,digits=5)
# 2 way is slightly different

# If I want to use this model for inference I need to unstandardize the coefficients before reporting them to make them more easily interpretable.

#way 3
jtools::summ(model_a.acc.logit, scale=TRUE, confint = TRUE,exp = TRUE, digits = 5)
# I feel this does not work

# way 4
# The first step in the process is to get the standardized estimates and confidence intervals from the model. I use tidy() from package broom for this, which returns a data.frame of coefficients, statistical tests, and confidence intervals. 
library(broom)
coef_st = tidy(model_a.acc.logit, effects = "fixed",
     conf.int = TRUE,
     conf.method = "profile")
sd_all = map( select(df_adult, Coh), sd) %>% 
     stack() %>%
     mutate(ind = 'scale(Coh)')
coef_unst_Coh = coef_st[2,] %>%
     inner_join(., sd_all, by = c("term" = "ind") ) %>%
     mutate_at( vars(estimate, conf.low, conf.high), funs(round( ./values, 4) ) ) 

## Further explanation of confint
### obtain confidence intervals for the coefficient estimates
confint(model.acc.logit2) 
# get the exact 95% confidence interval for the coefficients b
exp(confint(model.acc.logit2))
## use the parametric bootstrap to calculate confidence intervals
confint(model.acc.logit2, method="boot", nsim=1000, parm=1:3)
```
<!-- wald.test(b = coef(model.logit.interaction), Sigma = vcov(model.logit.interaction), Terms = 4:6) -->
AIC 5715, smaller AIC

``` {r acc-post-hoc}
# contrast within factor: pairwise comparison
# emeans cannot be installed in this r version
# check https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/
library(emmeans)
emmeans(model.acc.logit2, Acc ~ gender)
emm1.1<-emmeans(fit1, specs = pairwise ~ f1:f2, type = "response", adjust = "none")
emm1.1$contrasts %>%
     confint()
emm2 = emmeans(fit1, specs = pairwise ~ f1|f2, type = "response")
emm2

# way 1
library(multcomp)
summary(glht(model.acc.logit2, mcp(Gender="Tukey")))
summary(glht(model.acc.logit2, mcp(Coh="Tukey")))
```
```{r acc-cloglog-interaction, eval=FALSE}
model_a.acc.cloglog <- glmer(formula = form_a.probit, family=binomial(mafc.cloglog(2)), data = df_adult)
summary(model_a.acc.cloglog)
anova(model_a.acc.logit,model_a.acc.cloglog)
# ss <- getME(model.cloglog.interaction,c("theta","fixef"))
# m3 <- update(model.cloglog.interaction,start=ss,control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# summary(m3)
```
AIC 5768

```{r acc-weibull-interaction, eval=FALSE}
model_a.acc.weibull <- glmer(formula = form_a.probit, family=binomial(mafc.weib(2)), data = df_adult)
summary(model_a.acc.weibull)
anova(model_a.acc.logit,model_a.acc.weibull)
```

## Further examination for the models
### obtain confidence intervals for the coefficient estimates
confint(model.acc.logit) 
# get the exact 95% confidence interval for the coefficients b
exp(confint(model.logit.interaction))

```{r plot-sensitivity}
# It is important to check that your model is not influenced by one or a small set of observations. This might indicate your model is over fit or that your model is sensitive to the particular observations included in the model.
ggplot(data.frame(lev=hatvalues(model.fixed.rt2),pearson=residuals(model.fixed.rt2,type="pearson")),
      aes(x=lev,y=pearson)) +
    geom_point() +
    theme_bw()

# The following code determines which of the observations have the highest leverage and displays these observations. The code also generates a new model without these observations and then compares the coefficients for the will all observations to this new model with some observations removed.
# levId <- which(hatvalues(mm) >= .172)
# pbDat[levId,c("y","x1","x2","g1")]
# summary(pbDat[,c("y","x1","x2")])
# 
# mmLev <- lmer(y ~ x1 + x2 + (1|g1), data=pbDat[-c(levId),])
# mmLevCD <- data.frame(effect=fixef(mm),
#                      change=(fixef(mmLev) - fixef(mm)),
#                      se=sqrt(diag(vcov(mm)))
#                      )
# rownames(mmLevCD) <- names(fixef(mmLev))
# mmLevCD$multiples <- abs(mmLevCD$change / mmLevCD$se)
# mmLevCD
```

### plotting
#### Plot of speed across patterns by age
```{r p-corr-by-speed-and-age-plot}
# Evaluate Speed by Coherence interaction
spd.by.coh <- df.bysub.bycond %>%
  group_by(Speed, Coh, AgeYrs) %>%
  summarize(Pct.Corr.mean = mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.sem = sd(Pct.Corr, na.rm=TRUE)/sqrt( n() ))
limits = aes( ymax = Pct.Corr.mean + Pct.Corr.sem , ymin = Pct.Corr.mean - Pct.Corr.sem )
p6 <- 
  ggplot( data=spd.by.coh, aes(x=Coh, y=Pct.Corr.mean, color = AgeYrs) ) +
  facet_grid( facets = . ~ Speed ) +
  geom_line() +
  geom_pointrange( limits ) +
  xlim(0,1) +
  ylim(.4, 1) +
  ylab("p(corr)") +
  xlab("Coherence)") +
  theme_bw() +
  theme.custom +
  geom_hline(yintercept=0.5, linetype="dashed")
p6
```

# Plot of coherence by pattern across age
```{r p-corr-by-pattern-and-age-plot, include=TRUE}
patt.by.coh <- df.bysub.bycond %>%
  group_by(PatternType, Coh, AgeYrs) %>%
  summarize(Pct.Corr.mean = mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.sem = sd(Pct.Corr, na.rm=TRUE)/sqrt( n() ))

limits = aes( ymax = Pct.Corr.mean + Pct.Corr.sem , ymin = Pct.Corr.mean - Pct.Corr.sem )

p7 <- 
  ggplot( data=patt.by.coh, aes(x=Coh, y=Pct.Corr.mean, color = AgeYrs) ) +
  facet_grid( facets = ~ PatternType ) +
  geom_line() +
  geom_pointrange( limits ) +
  xlim(0, 1) +
  ylim(.4, 1) +
  ylab("p(corr)") +
  xlab("Coherence)") +
  theme_bw() +
  theme.custom +
  geom_hline(yintercept=0.5, linetype="dashed")
p7
```


### plot of mean and sd of Speed and patterntype
```{r plot-speed-patterntype}
df2 %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(AgeYrs, Gender, Age, SubID, PatternType, Speed, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) -> df3
            
df.speed_Pattern <- df3 %>%
  group_by(Speed,PatternType) %>%
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.se=sd(Pct.Corr)/sqrt(length(Pct.Corr)),
         RT.mean.mean=mean(RT.mean),
         RT.mean.se=sd(RT.mean)/sqrt(length(RT.mean)))
pd <- position_dodge(0.00) # The errorbars overlapped, so use position_dodge to move them horizontally
ggplot(df.speed_Pattern, aes(x=Speed, y=pcorr.mean, colour=PatternType, group=PatternType)) + 
    geom_errorbar(aes(ymin=pcorr.mean-pcorr.se, ymax=pcorr.mean+pcorr.se), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=2) +    #21 is filled circle
    xlab("Speed (deg/s)") +
    ylab("Percentage of Accuracy") +
    scale_colour_hue(name="Optic Flow Pattern",    #Legend label, use darker colors
                     breaks=c("linear", "radial"),
                     labels=c("Linear motion", "Radial Motion"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Optic Flow Speed and Pattern Type on Accuracy") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom 
   # theme(legend.justification=c(1,0),legend.position=c(1,0))               # Position legend in bottom right

ggplot(df.speed_Pattern, aes(x=Speed, y=RT.mean.mean, colour=PatternType, group=PatternType)) + 
    geom_errorbar(aes(ymin=RT.mean.mean-RT.mean.se, ymax=RT.mean.mean+RT.mean.se), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=2) +    #21 is filled circle
    xlab("Speed (deg/s)") +
    ylab("RT") +
    scale_colour_hue(name="Optic Flow Pattern",    #Legend label, use darker colors
                     breaks=c("linear", "radial"),
                     labels=c("Linear motion", "Radial Motion"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Optic Flow Speed and Pattern Type on reaction times") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
   theme(legend.justification=c(1,0),legend.position=c(1,0)) 
```
### plot of mean and sd of Speed and Coh
```{r p-corr-speed-coh}
df.speed_coh <- df.bysub.bycond %>%
  group_by(Speed,Coh) %>%
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.se=sd(Pct.Corr)/sqrt(length(Pct.Corr)),
         RT.mean.mean=mean(RT.mean),
         RT.mean.se=sd(RT.mean)/sqrt(length(RT.mean)))
         
pd <- position_dodge(0.01) # The errorbars overlapped, so use position_dodge to move them horizontally
ggplot(df.speed_coh, aes(x=Coh, y=pcorr.mean, colour=Speed, group=Speed)) + 
    geom_errorbar(aes(ymin=pcorr.mean-pcorr.se, ymax=pcorr.mean+pcorr.se), colour="black", width=.1, position=pd)+
    geom_line(position=pd) +
    geom_point(position=pd,size=2) +    #21 is filled circle
    xlab("Coherence (%)") +
    ylab("Percentage of Accuracy") +
    scale_colour_hue(name="Optic Flow Speed",    #Legend label, use darker colors
                     breaks=c("2deg/s", "8deg/s"),
                     labels=c("2 deg/s", "8 deg/s"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Optic Flow Speed and Coherence on Accuracy") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
    theme(legend.justification=c(1,0),legend.position=c(1,0))               # Position legend in bottom right

ggplot(df.speed_coh, aes(x=Coh, y=RT.mean.mean, colour=Speed, group=Speed)) + 
    geom_errorbar(aes(ymin=RT.mean.mean-RT.mean.se, ymax=RT.mean.mean+RT.mean.se), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=2) +    #21 is filled circle
    xlab("Cohernce (%))") +
    ylab("RT") +
    scale_colour_hue(name="Optic Flow Pattern",    #Legend label, use darker colors
                     breaks=c("2deg/s", "8deg/s"),
                     labels=c("2 deg/s", "8 deg/s"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Optic Flow Speed and Coherence on Reaction times") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
   theme(legend.justification=c(1,0),legend.position=c(1,0)) 
```
### plot of mean and sd of Patterntype and Coh
```{r p-corr-pattern-coh}
df.pattern_coh <- df.bysub.bycond %>%
  group_by(PatternType,Coh) %>%
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.se=sd(Pct.Corr)/sqrt(length(Pct.Corr)),
         RT.mean.mean=mean(RT.mean),
         RT.mean.se=sd(RT.mean)/sqrt(length(RT.mean)))
         
pd <- position_dodge(0.01) # The errorbars overlapped, so use position_dodge to move them horizontally
ggplot(df.pattern_coh, aes(x=Coh, y=pcorr.mean, colour=PatternType, group=PatternType)) + 
    geom_errorbar(aes(ymin=pcorr.mean-pcorr.se, ymax=pcorr.mean+pcorr.se), colour="black", width=.1, position=pd)+
    geom_line(position=pd) +
    geom_point(position=pd,size=2) +    #21 is filled circle
    xlab("Coherence (%)") +
    ylab("Percentage of Accuracy") +
    scale_colour_hue(name="Optic Flow Speed",    #Legend label, use darker colors
                     breaks=c("linear", "radial"),
                     labels=c("Linear motion", "Radial Motion"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Optic Flow Pattern Type and Coherence on Accuracy") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
    theme(legend.justification=c(1,0),legend.position=c(1,0))               # Position legend in bottom right

ggplot(df.pattern_coh, aes(x=Coh, y=RT.mean.mean, colour=PatternType, group=PatternType)) + 
    geom_errorbar(aes(ymin=RT.mean.mean-RT.mean.se, ymax=RT.mean.mean+RT.mean.se), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=2) +    #21 is filled circle
    xlab("Cohernce (%))") +
    ylab("RT") +
    scale_colour_hue(name="Optic Flow Pattern",    #Legend label, use darker colors
                    breaks=c("linear", "radial"),
                     labels=c("Linear motion", "Radial Motion"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Optic Flow pattern type and Coherence on Reaction times") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
   theme(legend.justification=c(1,0),legend.position=c(1,0)) 
```
### plot of mean and sd of Age and Coh
```{r p-corr-age-coh}
df.age_coh <- df3 %>%
  group_by(Age,Coh) %>%
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.se=sd(Pct.Corr)/sqrt(length(Pct.Corr)),
         RT.mean.mean=mean(RT.mean),
         RT.mean.se=sd(RT.mean)/sqrt(length(RT.mean)))
         
pd <- position_dodge(0.01) # The errorbars overlapped, so use position_dodge to move them horizontally
ggplot(df.age_coh, aes(x=Coh, y=pcorr.mean, colour=Age, group=Age)) + 
    geom_errorbar(aes(ymin=pcorr.mean-pcorr.se, ymax=pcorr.mean+pcorr.se), colour="black", width=.1, position=pd)+
    geom_line(position=pd) +
    geom_point(position=pd,size=2) +    #21 is filled circle
    xlab("Coherence (%)") +
    ylab("Percentage of Accuracy") +
    scale_colour_hue(name="Age",    #Legend label, use darker colors
                     breaks=c("5", "6", "7", "8"),
                     labels=c("5 year old", "6 year old","7 year old","8 year old"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Age and Optic Flow Coherence on Accuracy") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
    theme(legend.justification=c(1,0),legend.position=c(1,0))               # Position legend in bottom right

ggplot(df.age_coh, aes(x=Coh, y=RT.mean.mean, colour=Age, group=Age)) + 
    geom_errorbar(aes(ymin=RT.mean.mean-RT.mean.se, ymax=RT.mean.mean+RT.mean.se), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=2) +    #21 is filled circle
    xlab("Cohernce (%))") +
    ylab("RT") +
    scale_colour_hue(name="Age",    #Legend label, use darker colors
                     breaks=c("5", "6", "7", "8"),
                     labels=c("5 year old", "6 year old","7 year old","8 year old"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Age and Optic Flow Coherence on Reaction times") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
   theme(legend.justification=c(1,0),legend.position=c(1,0)) 
```

### plot of mean and sd of Age and Coh
```{r p-corr-age-patterntype}
df.age_pattern <- df3 %>%
  group_by(Age,PatternType) %>%
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.se=sd(Pct.Corr)/sqrt(length(Pct.Corr)),
         RT.mean.mean=mean(RT.mean),
         RT.mean.se=sd(RT.mean)/sqrt(length(RT.mean)))
         
pd <- position_dodge(0.01) # The errorbars overlapped, so use position_dodge to move them horizontally
ggplot(df.age_pattern, aes(x=Age, y=pcorr.mean, colour=PatternType, group=PatternType)) + 
    geom_errorbar(aes(ymin=pcorr.mean-pcorr.se, ymax=pcorr.mean+pcorr.se), colour="black", width=.1, position=pd)+
    geom_line(position=pd) +
    geom_point(position=pd,size=2) +    #21 is filled circle
    xlab("Age (yrs)") +
    ylab("Percentage of Accuracy") +
    scale_colour_hue(name="Age",    #Legend label, use darker colors
                     breaks=c("linear", "radial"),
                     labels=c("Linear motion", "Radial Motion"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Age and Optic Flow Pattern Type on Accuracy") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
    theme(legend.justification=c(1,0),legend.position=c(1,0))               # Position legend in bottom right

ggplot(df.age_pattern, aes(x=Age, y=RT.mean.mean, colour=PatternType, group=PatternType)) + 
    geom_errorbar(aes(ymin=RT.mean.mean-RT.mean.se, ymax=RT.mean.mean+RT.mean.se), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=2) +    #21 is filled circle
    xlab("Age (yrs)") +
    ylab("RT") +
    scale_colour_hue(name="Optic Flow Pattern",    #Legend label, use darker colors
                     breaks=c("linear", "radial"),
                     labels=c("Linear motion", "Radial Motion"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Age and Optic Flow Pattern Type on Reaction times") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
   theme(legend.justification=c(1,0),legend.position=c(1,0)) 
```

### plot of mean and sd of Age and Speed
```{r p-corr-age-speed}
df.age_speed <- df3 %>%
  group_by(Age,Speed) %>%
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.se=sd(Pct.Corr)/sqrt(length(Pct.Corr)),
         RT.mean.mean=mean(RT.mean),
         RT.mean.se=sd(RT.mean)/sqrt(length(RT.mean)))
         
pd <- position_dodge(0.01) # The errorbars overlapped, so use position_dodge to move them horizontally
ggplot(df.age_speed, aes(x=Age, y=pcorr.mean, colour=Speed, group=Speed)) + 
    geom_errorbar(aes(ymin=pcorr.mean-pcorr.se, ymax=pcorr.mean+pcorr.se), colour="black", width=.1, position=pd)+
    geom_line(position=pd) +
    geom_point(position=pd,size=2) +    #21 is filled circle
    xlab("Age (yrs)") +
    ylab("Percentage of Accuracy") +
    scale_colour_hue(name="Age",    #Legend label, use darker colors
                     breaks=c("2deg/s", "8deg/s"),
                     labels=c("2 deg/s", "8 deg/s"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Age and Optic Flow Speed on Accuracy") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
    theme(legend.justification=c(1,0),legend.position=c(1,0))               # Position legend in bottom right

ggplot(df.age_speed, aes(x=Age, y=RT.mean.mean, colour=Speed, group=Speed)) + 
    geom_errorbar(aes(ymin=RT.mean.mean-RT.mean.se, ymax=RT.mean.mean+RT.mean.se), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=2) +    #21 is filled circle
    xlab("Age (yrs)") +
    ylab("RT") +
    scale_colour_hue(name="Optic Flow Speed",    #Legend label, use darker colors
                      breaks=c("2deg/s", "8deg/s"),
                     labels=c("2 deg/s", "8 deg/s"),
                     l=40) +                    # Use darker colors, lightness=40
    ggtitle("The Effect of Age and Optic Flow Speed on Reaction times") +
   # expand_limits(y=0) +                        # Expand y range
   # scale_y_continuous(breaks=0:20*4) +         # Set tick every 4
    theme_bw() +
    theme.custom +
   theme(legend.justification=c(1,0),legend.position=c(1,0)) 
```

### Plot of actual  *p*(corr) and predicted *p*(corr) by condition
```{r p-corr-pattern-speed-plot-final, include=TRUE}
df.bysub.bycond %>% 
  group_by( Gender,Coh,Speed,PatternType) %>% 
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean)) -> 
  df.bygender.bycond
# add fitted line
xseq<-seq(0.05,0.2,len=100)
df.bysub.bycond$id<-with(df.bysub.bycond,interaction(Speed, PatternType,Gender, SubID))
nd<-data.frame(rep(xseq,8*29),id=rep(levels(df.bysub.bycond$id),each=100))
# levels(nd$id)<-levels(df.bysub.byage.bycond$id)
mm <-matrix(unlist(strsplit(as.character(nd$id),"[.]")), ncol=4,byrow=TRUE)
nd$Speed<-gsub("[[:space:]]", "",factor(mm[,1]))
nd$PatternType<-factor(mm[,2])
nd$Gender<-factor(mm[,3])
nd$SubID<-factor(mm[,4])
colnames(nd)[1] <- "Coh"

nd$acc.pred<-predict(model.acc.logit,newdata=nd,type="response",se.fit=TRUE) # obtain predicted values
nd$rt.pred<-exp(predict(model.log.rt2,newdata=nd, type="response", se.fit=TRUE)) # obtain predicted values

nd2 <- nd %>%
  group_by(Gender, Speed,Coh, PatternType) %>%
  summarize(acc.pred.mean=mean(acc.pred),
         acc.pred.se=sd(acc.pred)/sqrt(length(acc.pred)),
         RT.pred.mean=mean(rt.pred),
         RT.pred.se=sd(rt.pred)/sqrt(length(rt.pred)))
df.bygender.bycond$Speed<-factor(df.bygender.bycond$Speed)
# Plot of extual and predicted ACC
title_text <- 'Percentage of correct responses by Coherence, Pattern, and Speed in adult participants'
pic.acc<-ggplot(data=df.bygender.bycond, aes(x=Coh, y=pcorr.mean, color=Gender)) +
  geom_point(aes(group=Gender, color=Gender),size=2) +
  geom_line(data=nd2, aes(x=Coh,y=acc.pred.mean, group=Gender, color=Gender),size=1) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence (%)", y="Percentage of Accuracy") +
  ggtitle(title_text) +
  scale_colour_hue(name="participant gender",    #Legend label, use darker colors
                      breaks=c("Female", "Male"),
                     labels=c("Female", "Male"))+
  theme_bw() +
  theme.custom +
  xlim(0.05, 0.2) +
  geom_hline(yintercept=0.5, linetype="dashed")

pic.acc

# Plot of extual and predicted ACC
title_text <- 'Reaction Times by Coherence, Pattern, and Speed in adult participants'
pic.rt<-ggplot(data=df.bygender.bycond, aes(x=Coh, y=RT.mean.mean, color=Gender)) +
  geom_point(aes(group=Gender, color=Gender),size=2) +
  geom_line(data=nd2, aes(x=Coh,y=RT.pred.mean, group=Gender, color=Gender),size=1) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence (%)", y="Reaction times (s)") +
  ggtitle(title_text) +
  scale_colour_hue(name="participant gender",    #Legend label, use darker colors
                     breaks=c("Female", "Male"),
                     labels=c("Female", "Male"))+
  theme_bw() +
  theme.custom +
  xlim(0.05, 0.2) +
  geom_hline(yintercept=0.5, linetype="dashed")

pic.rt
```

