---
title: "MOCO_analysis"
author: "Yiming"
date: "`r Sys.time()`"
output: pdf_document
Description: this file indicates the statistical analysis of the MOCO projects (both children and adults)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lme4)
library(knitr)
library(psyphy)
library(sjPlot)
library(dplyr)
library(viridis)
library(ggplot2)
library(simr)

# if (!("pacman" %in% installed.packages()[,])) {
#     install.packages("pacman")
#   }
# library(pacman)
# pacman::p_load(dplyr, ggplot2, knitr, psyphy, lme4, sjPlot)
```

```{r ggplot-themes}
theme.custom <- theme(plot.title = element_text(size=16, face="bold"),
                      axis.title.x = element_text(size=14),
                      axis.title.y = element_text(size=14),
                      strip.text = element_text(size=14),
                      axis.text = element_text(size=11),
                      legend.position="bottom", 
                      legend.title=element_blank(),
                      legend.text=element_text(size=11))
```

## Import aggregate data

Here we import the aggregate data file found in `analyses/data-aggregate/moco-beh-child.csv`, convert `AgeDays` to a categorical factor, `AgeYrs` (norminal) and 'Age' (ordinal), convert gender into 1 (female) and 2 (male). In this dataset, the NaN of Acc is fixed but the outliers are not cleaned up.

file.exists("analysis/data/child/data-aggregate/moco-beh-child.csv")

# load data
```{r load-files}
df_child <- read.csv(file = "~/Documents/github/moco-psychophysics-child-adult/analysis/data/child/data-aggregate/moco-beh-child.csv", header = TRUE)
df_adult <- read.csv(file = "~/Documents/github/moco-psychophysics-child-adult/analysis/data/moco-adult.csv", header = TRUE)
df_child <- read.csv(file = "~/R/moco-psychophysics/analysis/data/child/data-aggregate/moco-beh-child.csv", header = TRUE)
df_adult <- read.csv(file = "~/R/moco-psychophysics/analysis/data/moco-adult.csv", header = TRUE)
df_adult$Speed <- factor(df_adult$Speed, labels = c("2 deg/s", "8 deg/s"))
df_child$Speed <- factor(df_child$Speed, labels = c("2 deg/s", "8 deg/s"))
df_child$SubID <- factor(df_child$SubID)
df_adult$SubID <- factor(df_adult$SubID)
df_child$Age <- df_child$AgeDays/365.25
df_child$AgeYrs <- ordered(cut(df_child$AgeDays/365.25, 
                 breaks = c(5,6,7,8,9), 
                 labels = c("5-year-old", "6-year-old", "7-year-old", "8-year-old")))
# df_child <- df_child %>%
#   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Age, AgeYrs, Response)
#df_adult <- df_adult %>%
#   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Age, Response)
df_all <- read.csv(file="~/Documents/github/moco-psychophysics-child-adult/analysis/CombinedData.csv", header=TRUE, sep=",")
df_all$SubID <- factor(df_all$SubID)
df_child1 <- df_child %>%
   dplyr::filter(Group == "linear-radial coh [.15 .3 .45 .6]") %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Age,  Response)
df_child1$Coherence<-ordered(df_child1$Coh, 
                 levels = c(0.15,0.30,0.45,0.60), 
                 labels = c("level1", "level2", "level3", "level4"))
df_adult$Coherence<-ordered(df_adult$Coh, 
                 levels=c(0.05,0.10,0.15,0.20), 
                 labels = c("level1", "level2", "level3", "level4"))
df_all1<-bind_rows(df_child1, df_adult) 
df_all1<- df_all1 %>%
  mutate(group=c(rep('Child',nrow(df_child1)),rep('Adult',nrow(df_adult))))
df_all1$SubID <- factor(df_all1$SubID)
#### 30 children and 29 adults, each has 320 data. But the first adult has 480 data.
```

## subject-level cleaning 
Let's check the plot of df2 for each subject by computing some summary statistics across trial and block. These summary values are saved to the  `df.bysub.bycond` data frame.
```{r summary-data}
# summary statistics of child data 
df_child %>% 
  group_by(Gender, SubID, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) -> 
  df_child.summary

# df_child.summary <- df_child.summary %>%
#   group_by(Coh) %>%
#   mutate(pcorr.mean=mean(Pct.Corr),
#          pcorr.sd=sd(Pct.Corr),
#          RT.mean.mean=mean(RT.mean),
#          RT.mean.sd=sd(RT.mean))
# pcorr.mean and RT.mean.mean is the mean of Coherence condition.

# summary statistics of df2 by condition
df_child %>% 
  group_by(SubID, Age, Gender, AgeYrs, PatternType, Speed, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) -> 
  df_child.bysub.bycond

df_child.bysub.bycond <- df_child.bysub.bycond %>%
  group_by(PatternType,Speed,Coh) %>%
  mutate(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean) )
# pcorr.mean and RT.mean.mean is the mean of three condition. It is for make plot.
```

```{r test-normality}
# the y axis represents the observations and the x axis represents the quantiles modeled by the distribution. The solid line represents a perfect distribution fit and the dashed lines are the confidence intervals of the perfect distribution fit
library(car)
qqp(df2$Acc,"norm")
# lognormal
qqp(df2$Acc,"lnorm")
# test normality of RT 
hist(df2$RT,breaks=100)
qqPlot(df2$RT)
qqnorm(df2$RT); qqline(df2$RT)
# lognormal
qqp(df2$RT,"lnorm")
df2 %>%         # From the output, the p-value > 0.05 implying that the distribution of the data are not significantly different from normal distribution. In other words, we can assume the normality.
  group_by(SubID) %>% 
  summarize(results = data_frame(shapiro.test(RT)))->shapiroresult  # the result show all subject do not have normal distribution of RT. the linear mixed-effect model do not require the normality. but the residual need to dit the normal distribution
# qqp requires estimates of the parameters of the negative binomial, Poisson
# and gamma distributions. You can generate estimates using the fitdistr
# function. Save the output and extract the estimates of each parameter as I
# have shown below.
library(MASS)
# you might actually have something that fits a specific non-linear model (hierarchical generalized linear model or generalized linear mixed model) which has a link function, such as a Poisson model or a negative binomial. 
nbinom <- fitdistr(c(na.exclude(df2$RT)), "Negative Binomial") 
qqp(na.exclude(df2$RT), "nbinom", size = nbinom$estimate[[1]], mu = nbinom$estimate[[2]])
#poisson <- fitdistr(recog$Aggression.t, "Poisson")
#qqp(recog$Aggression.t, "pois", poisson$estimate)   #for positive integer
gammad <- fitdistr(c(na.exclude(df2$RT)), "gamma")
qqp(na.exclude(df2$RT), "gamma", shape = gammad$estimate[[1]], rate = gammad$estimate[[2]])
```

### plot of *p*(Corr) by subj
```{r p-corr-subj-mean-plot}
# Plot theme, customizations 
y_lbl <- 'p(corr)'
title_text <- 'p(corr) by subj'

# lines for each subj
p1 <- ggplot(df_child.summary, aes(Coh, Pct.Corr)) +
   geom_line(aes(group=SubID, color=AgeYrs)) +
   labs(x="Coherence", y=y_lbl) +
   ggtitle(title_text) +
   theme_bw() +
   theme.custom +
   xlim(0, 1) +
   geom_hline(yintercept=0.5, linetype="dashed")

 sd = 3
 df_child.summary <- df_child.summary %>%
   group_by(Coh) %>%
   mutate(pcorr.lower_bound = pcorr.mean-sd*pcorr.sd,pcorr.upper_bound=pcorr.mean+sd*pcorr.sd)

#confidence band
p1 <- p1 +
   geom_line(aes(Coh, pcorr.mean), size = 2) +
   geom_ribbon(aes(ymin = pcorr.lower_bound, ymax =pcorr.upper_bound), fill = "grey70",
                 alpha=0.5)       #transparency

 p1
 # I can try geom_smooth function next time
# from the plot, we can see the accuracy of subj 1088 has below average percentage of accuracy. But it is not significant
```
 
### plot of RT by subj
```{r RT-subj-mean-plot}
# Plot theme, customizations
y_lbl <- 'RT'
title_text <- 'RT by subj'

# lines for each subj
p2 <- ggplot(df.summary, aes(Coh, RT.mean)) +
   geom_line(aes(group=SubID, color=AgeYrs)) +
   labs(x="Coherence", y=y_lbl) +
   ggtitle(title_text) +
   theme_bw() +
   theme.custom +
   xlim(0, 1) +
   geom_hline(yintercept=0.5, linetype="dashed")


sd = 3
df.summary <- df.summary %>%
   group_by(Coh) %>%
   mutate(RT.lower_bound = RT.mean.mean-sd*RT.mean.sd,RT.upper_bound=RT.mean.mean+sd*RT.mean.sd)

# confidence band
p2 <- p2 +
   geom_line(aes(Coh, RT.mean.mean), size = 2) +
   geom_ribbon(aes(ymin = RT.lower_bound, ymax =RT.upper_bound), fill = "grey70",
                 alpha=0.5)       #transparency

p2
```

### Plot of *p*(corr) by condition
```{r p-corr-pattern-speed-plot, include=TRUE}
y_lbl <- 'Percentage of Correct Responses (%)'
title_text <- 'Accuracy by Coherence, Pattern, and Speed in child datasets'

sd = 3
df_child.bysub.bycond <- df_child.bysub.bycond %>%
  group_by(PatternType, Speed,Coh) %>%
  mutate(lower_bound = pcorr.mean-sd*pcorr.sd,upper_bound=pcorr.mean+sd*pcorr.sd)
# Plot for all subs
p.corr <- ggplot(data=df_child.bysub.bycond, aes(x=Coh, y=Pct.Corr*100))
p.corr <- p.corr +
  geom_line(aes(group=SubID, color=AgeYrs)) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence", y=y_lbl) +
  ggtitle(title_text) +
  theme_bw() +
  theme.custom +
  xlim(0, 1) +
  geom_hline(yintercept=0.5, linetype="dashed")
# confidence band
p.corr <- p.corr +
  geom_line(aes(Coh, pcorr.mean), size = 2) +
  geom_ribbon(aes(ymin = lower_bound, ymax =upper_bound), fill = "grey70",
                alpha=0.5)
p.corr
# we can see the small variance at the coherence level of .20, .40, .80 for small sample size. In radial condition, one subj (1088) is deviant in speed of 2 deg/s and 1059 is deviant in speed of 8 deg/s.
```

### Plot of RT by condition
```{r rt-pattern-speed-plot, include=TRUE}
# Plot RTs
y_lbl <- 'RT (s)'
title_text <- 'RT by Coherence, Pattern, and Speed'

sd = 3
df.bysub.bycond <- df.bysub.bycond %>%
  group_by(PatternType, Speed,Coh) %>%
  mutate(lower_bound = RT.mean.mean-sd*RT.mean.sd,upper_bound=RT.mean.mean+sd*RT.mean.sd)

# Plot for all subs
p.rt <- ggplot(data=df.bysub.bycond, aes(x=Coh, y=RT.mean))
p.rt <- p.rt +
  geom_line(aes(group=SubID, color=AgeYrs)) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence", y=y_lbl) +
  # ggtitle(title_text) +
  theme_bw() +
  theme.custom +
  xlim(0, 1)
# confidence band
p.rt <- p.rt +
  geom_line(aes(Coh, RT.mean.mean), size = 2) +
  geom_ribbon(aes(ymin = lower_bound, ymax =upper_bound), fill = "grey70",
                alpha=0.5)
p.rt
# In condition of speed of 2, there are 2 deviance (one subj 1077 deviant from the mean in both linear condition and radial condition)
```
#Generalized linear mixed effects model with a probit link/ logit link/ weibull model
Generalized linear mixed effects model 
The level 1 (i) is accuracy/RT in each condition for each subject. The level 2 (j) is each subject. The random effects in this model are SubID, Gender and AgeYrs. Fixed effects are Speed, PatternType, Coh, and their interaction
$Y_{i,j}=B_{0j} + B_{1j}*PatternType_{ij}+B_{2j}*Speed_{ij}+B_{3j}*Coh_{ij}+e_{ij}$
$B_{0,j} = r_{00}+ r_{01}*Age_{j}+r_{02}*Gender_{j}+u_{0j}$
$B_{1,j} = r_{10}+u_{1j}$
$B_{2j} = r_{20}+u_{2j}$
$B_{3j} = r_{30}+u_{3j}$

## Accuracy 
df_child$Speed <- factor(df_child$Speed, labels = c("2 deg/s", "8 deg/s"))
df_child$SubID <- factor(df_child$SubID)
Rescale and center continuous parameters
df_child$Coh_scaled<- scale(df_child[,7])
df_child$Age_scaled<- scale(df_child[,8])
df2$AgeYrs <- factor(df2$AgeYrs,ordered = FALSE) # the variables can not be ordinal, it will have L, C, Q
### probit link function
#### Empty model
```{r acc-probit-empty, eval=FALSE}
form.empty <- Acc~(1|SubID)
model.acc.empty <- glmer(formula = form.empty, family=binomial(mafc.probit(2)), data = df_child)
summary(model.acc.empty)
```

```{r ICC-Acc, eval=FALSE}
ICC_Acc <- 0.1289/(0.1289+0.8074)
# The result is the same as the uncleaned one
```
ICC is small (14%)
#### full model with random intercept
```{r acc-probit-without-Gender-Age, eval=FALSE}
form.fixed <- Acc ~ Coh + Speed + PatternType  + (1|SubID)
model.acc.fixed <- glmer(formula = form.fixed, family=binomial(mafc.probit(2)), data = df_child)
summary(model.acc.fixed)
```
AIC 5753

#### full model with random intercept and random slope
```{r acc-probit-random-slope-gender, eval=FALSE}
model.gender<- Acc ~ Coh + Speed + PatternType + (1+Gender|SubID)
model.acc.gender<- glmer(formula = model.gender, family=binomial(mafc.probit(2)),  glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),data = df_child)
summary(model.acc.gender)
```

AIC 5757
```{r acc-probit-random-slope-AgeYrs, eval=FALSE}
form.age <- Acc ~ Coh + Speed + PatternType + (Age+1|SubID)
model.acc.age <- glmer(formula = form.age, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),data = df_child)
summary(model.acc.age)
```

AIC 5755
AIC does not decrease in the random slope model

#### age and gender as fixed effect
```{r acc-probit-without-gender, eval=FALSE}
form.fixed1 <- Acc ~ Coh + Speed + PatternType + Age + (1|SubID)
model.acc.fixed1 <- glmer(formula = form.fixed1, family=binomial(mafc.probit(2)),  data = df_child)
summary(model.acc.fixed1)
library(lmtest)
lrtest(model.acc.fixed,model.acc.fixed1) # likelihood test: not significant
# wardtest(model.acc.fixed,model.acc.fixed1)
anova(model.acc.fixed,model.acc.fixed1)  # waldtest: significant
```
AIC 5732

```{r acc-probit-without-age, eval=FALSE}
form.fixed2 <- Acc ~ Coh + Speed + PatternType + Gender + (1|SubID)
model.acc.fixed2 <- glmer(formula = form.fixed2, family=binomial(mafc.probit(2)), data = df2)
summary(model.acc.fixed2)
anova(model.acc.fixed,model.acc.fixed2) #significant
```
AIC 5748
```{r acc-probit-full, eval=FALSE}
form.full <- Acc ~ scale(Coh) + Speed + PatternType + Gender + scale(Age) + (1|SubID)
model.acc.full <- glmer(formula = form.full, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.full)
anova(model.acc.fixed,model.acc.full)  # significant
```
#### interaction effect
```{r acc-probit-interaction, eval=FALSE}
form.full1<- Acc ~  scale(Age) + Gender + scale(Coh)*Speed*PatternType + (1|SubID)
model.acc.full1 <- glmer(formula = form.full1, family=binomial(mafc.probit(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), , data = df_child)
summary(model.acc.full1)
anova(model.acc.full1,model.acc.full)  #better fit
```
```{r acc-probit-interaction-gender-age, eval=FALSE}
form.full2<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + scale(Age)*scale(Coh) +scale(Age)*Speed + scale(Age)*PatternType+scale(Age)*Gender+Gender*scale(Coh) + Gender*Speed + Gender*PatternType+ (1|SubID)
model.acc.full2 <- glmer(formula = form.full2, family=binomial(mafc.probit(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.full2)
anova(model.acc.full1,model.acc.full2)  # better fit
## scale(Coh)*Speed , scale(Age)*scale(Coh) is significnant
```
# ##### bumped up max number of iterations.
#  ss <- getME(model.acc.full,c("theta","fixef"))
# <!-- m2 <- update(model.acc.full,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4))) -->
# still failed,  Try a different optimizer
# 
# ```{r find-optimizer}
# model.acc.full.new <- update(model.acc.full,start=ss,control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# summary(model.acc.full.new)

```{r acc-probit-full, eval=FALSE}
form.full3<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed  ++scale(Age)*Speed+ (1|SubID) #Age*Coh design related
model.acc.full3 <- glmer(formula = form.full3, family=binomial(mafc.probit(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.full3)
anova(model.acc.full2,model.acc.full3)  # better fit
## scale(Coh)*Speed , scale(Age)*scale(Coh) is significnant
```
### logit link function
```{r acc-logit-interaction, eval=FALSE}
form.acc.logit<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed +scale(Age)*Speed+ (1|SubID) #Age*Coh design related
model.acc.logit <- glmer(formula = form.acc.logit, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.logit)
anova(model.acc.logit,model.acc.full3) 
# ss <- getME(model.cloglog.interaction,c("theta","fixef"))
# m2 <- update(model.cloglog.interaction,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4)))
```

```{r get-coefficient-child}
# get coefficient
# str(df_child)
form.acc.logit2<- Acc ~ scale(Coh) + Speed + PatternType + Age + Gender + scale(Coh)*Speed  +Age*Speed+ (1|SubID) #Age*Coh design related
model.acc.logit2 <- glmer(formula = form.acc.logit2, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.logit2)
anova(model.acc.logit2)
lmerTest::anova(model.acc.logit2)
car::Anova(model.acc.logit2, type=3)  # this is betterm because F is said not work in glmer model
car::Anova(model.acc.logit2) # there is slight difference between scaled and unscaled
# afex::mixed(RT ~ Coh + Speed + PatternType + Age + Gender + Coh*Speed +Age*Speed+ (1|SubID), data=df_child, method = "S",  control = lmerControl(optCtrl = list(maxfun = 1e6)))
afex::mixed(Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + (1|SubID),family=binomial, data=df_child, method = "PB")
knitr::kable(model.acc.logit2)
## the same 
# anova(model.acc.logit2,test="F")
## Type I Analysis of Variance Table with Satterthwaite's method
# anova(model.acc.logit2, type=1)
```
```{r test-child}
# get coefficient
# str(df_child)
form.acc.logit3<- Acc ~ scale(Coh) + Speed + PatternType + Age + Gender + scale(Coh)*Speed  +Age*Speed+ (Age|SubID) #Age*Coh design related
model.acc.logit3 <- glmer(formula = form.acc.logit3, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_child)
summary(model.acc.logit3)
car::Anova(model.acc.logit3)
# boundary (singular) fit: see ?isSingular
# it is because it is a complex model, there are 30 age value
anova(model.acc.logit3, model.acc.logit2)
```
```{r calculate_r^2_ICC}
# calculate the marginal R^2 and conditional R^2
MuMIn::r.squaredGLMM(model.acc.logit2)

# for binomial response data
#compute the marginal R-square
#compute the variance in the fitted values
VarF <- var(as.vector(fixef(model.acc.logit2) %*% t(model.acc.logit2@pp$X)))
# VarCorr() extracts variance components
# attr(VarCorr(lmer.model),’sc’)^2 extracts the residual variance, VarCorr()$plot extract the variance of the plot effect
VarF/(VarF + VarCorr(model.acc.logit2)[[1]][1] + attr(VarCorr(model.acc.logit2), 'sc')^2 + (pi^2)/3)

#compute the conditionnal R-square
(VarF + VarCorr(model.acc.logit2)[[1]][1])/(VarF + VarCorr(model.acc.logit2)[[1]][1] + (attr(VarCorr(model.acc.logit2), 'sc')^2) + (pi^2)/3)
# The residual deviance in logistic regression is fixed to (pi ^ 2) / 3

form.empty <- Acc~1+(1|SubID)
mod0 <- glmer(formula = form.empty, family=binomial(mafc.logit(2)), data = df_child)
summary(mod0)
# computing the percent of explained variance for the plot slope
1 - (VarCorr(model.acc.logit2)[[1]][1]^2/VarCorr(mod0)[[1]][1]^2)
# for the residuals
1 - (var(residuals(model.acc.logit2))/var(residuals(mod0)))

## other way
performance::r2(model.acc.logit2)

# ICC
# extracting tau^2 for the varying intercept
tau2 <- brms::VarCorr(model.acc.logit2)[[1]][1]^2

# computing the ICC for the intercept
ICC1 <- tau2 / (tau2 + (pi^2 / 3) )
ICC1
performance::icc(model.acc.logit2)
```
```{r get-df}
# get df. One way afex does not work for glmer, try lmer to get df, which should be the same as the glmer
model.acc.logit_lmer <- lmer(formula = form.acc.logit2,  data = df_child)
summary(model.acc.logit_lmer)
anova(model.acc.logit_lmer)
```

```{r get-95%CI&OR-child}
# Way 1
se <- sqrt(diag(vcov(model.acc.logit2)))
# table of estimates with 95% CI
tab <- cbind(OR = fixef(model.acc.logit2), LL = fixef(model.acc.logit2) - 1.96 * se, UL = fixef(model.acc.logit2) + 1.96 * se)
# however, this result is different from the below
print(exp(tab))

# way 2
cc <- confint(model.acc.logit2)  ## slow (~ 11 seconds)
cc2 <- confint(model.acc.logit)  # test whether diff between scaled and unscaled
# get oR and 95% CI
ctab <- cbind(OR=fixef(model.acc.logit2),cc)
# Exponentiate to get odds ratios:
rtab <- exp(ctab)
print(rtab,digits=4)
# 2 way is slightly different

# way 3
profile.merMod 
confint.merMod

## Further explanation of confint
### obtain confidence intervals for the coefficient estimates
confint(model.acc.logit2) 
# get the exact 95% confidence interval for the coefficients b
exp(confint(model.acc.logit2))
## use the parametric bootstrap to calculate confidence intervals
confint(model.acc.logit2, method="boot", nsim=1000, parm=1:3)

# calculate the power
powerSim(model.acc.logit2,test=fixed("Speed","lr"),
                          seed=1234, #set for replication
                          nsim=100, alpha=.05, progress=FALSE) #options

powerSim(fit_catmodel,test=random(), #empty becasue only one
                          seed=1234, #set for replication
                          nsim=100, alpha=.05, progress=FALSE) #options
```
<!-- wald.test(b = coef(model.logit.interaction), Sigma = vcov(model.logit.interaction), Terms = 4:6) -->
AIC 5715, smaller AIC
## plot
```{r plot the fitted line}
#predict gives the predicted value in terms of logits
plot.dat <- data.frame(prob= df_child$Acc/sum(df_child$Acc),
                       age = df_child$Age,
                       fit = predict(model.acc.logit2, df_child))
#convert those logit values to probabilities
plot.dat$fit_prob <- exp(plot.dat$fit)/(1+exp(plot.dat$fit))

library(ggplot2)
ggplot(plot.dat, aes(x=age, y=prob)) + 
  geom_point() +
  geom_line(aes(x=age, y=fit_prob))
```

``` {r acc-post-hoc}
# contrast within factor: pairwise comparison
# emeans cannot be installed in this r version
# check https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/
library(emmeans)
emmeans(model.acc.logit2, Acc ~ Gender)
emm1.1<-emmeans(fit1, specs = pairwise ~ f1:f2, type = "response", adjust = "none")
emm1.1$contrasts %>%
     confint()
emm2 = emmeans(fit1, specs = pairwise ~ f1|f2, type = "response")
emm2

# way 1
lsmeans::lsmeans(model.acc.logit2, pairwise~Coh*Speed, adjust="tukey")
lsmeans::lsmeans(model.acc.logit2, pairwise~Age*Speed, adjust="tukey")

# way 2
library(multcomp)
summary(glht(model.acc.logit2, mcp(Gender="Tukey")))
summary(glht(model.acc.logit2, mcp(Coh="Tukey")))
```

```{r acc-cloglog-interaction, eval=FALSE}
# Can fit a Weibull function, but use log contrast as variable 
# see http://finzi.psych.upenn.edu/library/psyphy/html/mafc.html

form.acc.cloglog<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + scale(Age)*Speed+  (1|SubID)
model.acc.cloglog <- glmer(formula = form.acc.cloglog, family=binomial(mafc.cloglog(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),  data = df_child)
summary(model.acc.cloglog)
anova(model.acc.logit,model.acc.cloglog) 
anova(model.acc.cloglog,model.acc.full3) 
# ss <- getME(model.cloglog.interaction,c("theta","fixef"))
# m3 <- update(model.cloglog.interaction,start=ss,control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# summary(m3)

# Weibull parameters \alpha and \beta
cc <- coef(model.acc.cloglog)
alph <- exp(-cc[1]/cc[2])
bet <- cc[2]
```
AIC 5768

### Weibull function
```{r weibull-interaction, eval=FALSE}
library(psyphy)
form.acc.weibull<- Acc ~ scale(Coh) + Speed + PatternType + scale(Age) + Gender + scale(Coh)*Speed + (1|SubID)
model.acc.weibull <- glmer(formula = form.acc.weibull, family=binomial(mafc.weib(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),  data = df_child)
summary(model.acc.weibull)
```
AIC 5734
accfit <- fitdist(df.bysub.bycond$Pct.Corr,"weibull") # by conditions?
accfit   # estimate
weibull(,shape=9.3969663,scale=0.9412456)

# library(VGAM)
# form.weibull.interaction<- Acc ~ Coh + Speed + PatternType + Coh*Speed*PatternType + (1|SubID)
# model.weibull.interaction <- vglm(formula = form.weibull.interaction, family = weibull(link='log'), data = df)
# summary(model.weibull.interaction)



<!-- ### wald test -->
<!-- ```{r comparsion} -->
<!-- #### compare two models -->
<!-- waldtest(model.acc.logit,model.acc.probit)  -->
<!-- #### post hoc -->
<!-- anova(model.acc.logit)    # a wald test for the fixed effects -->
<!-- wald.test(b = coef(model.acc.logit), Sigma = vcov(model.acc.logit), Terms = 2) <!-- #test Coh --> -->
<!-- wald.test(b = coef(model.acc.logit), Sigma = vcov(model.acc.logit), Terms = 3) <!-- #test Speed --> -->
<!-- wald.test(b = coef(model.acc.logit), Sigma = vcov(model.acc.logit), Terms = 4) <!-- #test Pattern --> -->
<!-- wald.test(b = coef(model.acc.logit), Sigma = vcov(model.acc.logit), Terms = 5) <!-- #test Coh::Speed --> -->
<!-- <!-- l <- cbind(0, 0, 0, 1, -1, 0) -->
<!-- wald.test(b = coef(myprobit), Sigma = vcov(myprobit), L = l) --> -->
<!-- ``` -->

<!-- ```{r correct response by log of Coh, Speed, PatternType} -->
<!-- df2$accfit <- fitted(model.acc.logit)  # shall I include the age and gender? -->
<!-- df2 %>%  -->
<!--   group_by(Age, PatternType, Speed, Coh) %>%  -->
<!--   summarize(N.corr = sum(Acc),  -->
<!--             N.tot = n(),  -->
<!--             Pct.Corr = N.corr/N.tot, -->
<!--             RT.mean=mean(RT, na.rm = T), -->
<!--             RT.sd=sd(RT, na.rm = T)) ->  -->
<!--   df.bycond -->

<!-- library(lattice) -->
<!-- xyplot(Pct.Corr~ Coh | Speed * PatternType, data = df.bycond, -->
<!-- 	subscripts = TRUE,  -->
<!-- 	# ID = with(ecc2, Size + as.numeric(task)), -->
<!-- 	scale = list(x = list(log = TRUE),  -->
<!-- 				 y = list(limits = c(0, 1))), -->
<!-- 	xlab = "Coherence", ylab = "Proportion Correct Response", -->
<!-- 	aspect = "xy", -->
<!-- 	panel = function(x, y, subscripts, ID, ...) { -->
<!-- 		which = unique(ID[subscripts]) -->
<!-- 		llines(x, ecc2$fit[which ==ID], col = "black", ...) -->
<!-- 		panel.xyplot(x, y, pch = 16, ...) -->
<!-- 		panel.abline(h = 0.25, lty = 2, ...) -->
<!-- 		} -->
<!-- ) -->
<!-- ``` -->

<!-- ```{r Acc-coef-plot1, include=TRUE} -->
<!-- ### obtain confidence intervals for the coefficient estimates -->
<!-- confint(model.acc.logit)  -->
<!-- # get the exact 95% confidence interval for the coefficients b -->
<!-- exp(confint(model.logit.interaction)) -->
<!-- #ranef(model.full,confVar=T) -->
<!-- #A generic function to extract the conditional modes of the random effects from a fitted model object. -->
<!-- #coef(model.full) -->
<!-- #coef is a generic function which extracts model coefficients from objects returned by modeling functions. coefficients is an alias for it. -->
<!-- hist(ranef(m3)$SubID[1:30,],xlab="U0j",main="Histogram of random effects") -->
<!-- hist(coef(m3)$SubID[1:30,1],xlab="Random intercepts",main="Histogram of random intercepts") -->
<!-- ``` -->

<!-- ```{r subject-specific-regression-plot1} -->
<!-- #plot lines for the first 5 schools based on the posterior means (M3) -->
<!-- plot(x=c(0,1),y=c(0,1),type="n",xlab="fixed effects",ylab="Acc",main="Subject-specific regression lines, m3") -->
<!-- for(i in 1:30) { -->
<!-- abline(a=coef(model.acc.logit)$SubID[i,1],b=coef(model.acc.logit)$SubID[i,2]) -->
<!-- } -->
<!-- ``` -->
<!-- ### make prediction -->
<!-- ```{r acc-prediction-plot} -->
<!-- prediction.acc <- data.frame(SubID = foo[["names"]],Coh = rep(seq(from = 15, to = 80, length.out = 100),  -->
<!--     2 * 2 * 30), Speed = factor(rep(c(2, 8), each = 100*30)), PatternType = factor(rep(c('linear','radial'), each=100*30))) -->
<!-- prediction.acc[, c("pcorr", "se")] <- predict(model.acc.logit, prediction.acc, type = "response", se.fit = TRUE)[-3] -->
<!-- ggplot(prediction.acc, aes(x = Coh, y = pcorr, colour = Age)) + geom_line() + facet_grid(facets = Speed ~ PatternType)  + theme_bw() + theme.custom  -->
<!-- # add age -->
<!-- ``` -->
<!-- library(car -->
<!-- car::outliers<-outlierTest(model.acc.logit, cutoff=0.05, n.max=30, order=TRUE, labels=names(rstudent), ...) -->

<!-- # Reports the Bonferroni p-values for testing each observation in turn to be a mean-shift outliner, based Studentized residuals in linear (t-tests) and generalized linear models (normal tests). -->


<!-- odd<-predict(model.logit.interaction,data.frame(Acc=c(, , ,))) -->
<!-- log_odds<-predict(model.logit.interaction,data.frame(b0*Coh + Speed + PatternType + Coh*Speed*PatternType)=c(0.25,0.5,0.75))) -->
<!-- exp(lodds)/(1+exp(lodds)) -->

### plotting

#### Plot of comparison of link functions
```{r p-corr-by-link-function}
# Evaluate Speed by Coherence interaction
y_mean <- df_child.summary %>%
  group_by(Coh) %>%
  summarize(Pct.Corr.mean = mean(Pct.Corr, na.rm=TRUE))
      #      Pct.Corr.sem = sd(Pct.Corr, na.rm=TRUE)/sqrt( n() ))
# limits = aes( ymax = Pct.Corr.mean + Pct.Corr.sem , ymin = Pct.Corr.mean - Pct.Corr.sem )
x <- seq(0, 0.8, 0.01)
data.frame(Coh=x, y_probit,y_logit,y_weibull)
y_probit <- predict(model.acc.full3, list(Coh = x), type = "response")
y_logit <- predict(model.acc.logit, list(Coh = x), type = "response")
y_weibull <- predict(model.acc.cloglog, list(Coh = x), type = "response")

p <- 
  ggplot( data=spd, aes(x=Coh, y=Pct.Corr.mean) ) +
  geom_line() +
  # geom_pointrange( limits ) +
  xlim(0,1) +
  ylim(.6, 1) +
  ylab("p(corr)") +
  xlab("Coherence)") +
  theme_bw() +
  theme.custom +
# geom_hline(yintercept=0.5, linetype="dashed")
  geom_line(data = y_probit, aes(x = dates, y = Difference), color = "blue") +
p

lines(x, y_probit, lwd = 1.5, col = "steelblue",, lty = 2)
lines(x, y_logit, lwd = 1.5, col = "green", lty = 2)
lines(x, y_logit, lwd = 1.5, col = "red", lty = 2)

# add a legend
legend("topleft",
       horiz = TRUE,
       legend = c("Probit", "Logit","Weibull"),
       col = c("steelblue", "green","red"), 
       lty = c(1, 2))
```
#### Plot of speed across patterns by age
```{r p-corr-by-speed_pattern-age-plot}
df_child2.bysub.bycond <- df_child %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(SubID, Age, Gender, AgeYrs, PatternType, Speed, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T))

df_p1_c_acc <- df_child2.bysub.bycond %>%
    group_by(PatternType,Speed,Coh, AgeYrs) %>%
    summarize( n=n(),
               Pct.Corr.mean = 100* mean(Pct.Corr, na.rm=TRUE),
               Pct.Corr.ci = 100*1.96*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))
# it is very strange to say the sd of accuracy
limits = aes( ymax = Pct.Corr.mean + Pct.Corr.ci , ymin = Pct.Corr.mean - Pct.Corr.ci)
pd <- position_dodge(0.1)
p1_c_acc <- 
  ggplot(data=df_p1_c_acc , aes(x=Coh, y=Pct.Corr.mean, color = AgeYrs) ) +
  facet_grid( facets = PatternType ~ Speed ) +
  geom_line() +
  # geom_point() +
  geom_pointrange( limits) +
  xlim(0.15,0.60) +
  ylim(42, 105) +
  ylab("Percentage of correct responses (%)") +
  xlab("Coherence level") +
  theme_bw() +
  theme.custom  +
  scale_colour_brewer(palette = "Set1")  +
  scale_x_continuous(breaks=seq(0.15, 0.60, 0.15))
  # geom_hline(yintercept=0.5, linetype="dashed")
p1_c_acc
```
#### Plot of interaction effects
```{r coh_speed_interaction_child}
# Plot of coherence by speed
plot_fit<-function(m,focal_var,inter_var=NULL,RE=NULL,offset=NULL,n=20,n_core=4,boot_mer=FALSE){
  require(arm)  
  dat<-model.frame(m)
  #turn all character variable to factor
  dat<-as.data.frame(lapply(dat,function(x){
    if(is.character(x)){
      as.factor(x)
    }
    else{x}
  }))
  #make a sequence from the focal variable
  x1<-list(seq(min(dat[,focal_var]),max(dat[,focal_var]),length=n))
  #grab the names and unique values of the interacting variables
  isInter<-which(names(dat)%in%inter_var)
  if(length(isInter)==1){
    x2<-list(unique(dat[,isInter]))
    names(x2)<-inter_var
  }
  if(length(isInter)>1){
    x2<-lapply(dat[,isInter],unique)
  }
  if(length(isInter)==0){
    x2<-NULL
  }
  #all_var<-x1
  #add the focal variable to this list
  all_var<-c(x1,x2)
  #expand.grid on it
  names(all_var)[1]<-focal_var
  all_var<-expand.grid(all_var)
     
  #remove varying variables and non-predictors and potentially offset variables
  if(!is.null(offset)){
    off_name <- grep("^offset",names(dat),value=TRUE)#this is needed because of the weird offset formatting in the model.frame
  }
  dat_red<-dat[,-c(1,which(names(dat)%in%c(focal_var,inter_var,RE,"X.weights."))),drop=FALSE]
  #if there are no variables left over that need averaging
  if(dim(dat_red)[2]==0){
    new_dat<-all_var
    name_f <- NULL
  }
  else{
    #otherwise add these extra variables, numeric variable will take their mean values
    #and factor variables will take their first level before being averaged out lines 86-87
    fixed<-lapply(dat_red,function(x) if(is.numeric(x)) mean(x) else factor(levels(x)[1],levels = levels(x)))
    #the number of rows in the new_dat frame
    fixed<-lapply(fixed,rep,dim(all_var)[1])
    #create the new_dat frame starting with the varying focal variable and potential interactions
    new_dat<-cbind(all_var,as.data.frame(fixed)) 
    #get the name of the variable to average over
    name_f<-names(dat_red)[sapply(dat_red,function(x) ifelse(is.factor(x),TRUE,FALSE))]
  }  
  #add an offset column set at 0 if needed
  if(!is.null(offset)){
    new_dat[,offset] <- 0
  }
       
     
  #get the predicted values
  cl<-class(m)[1]
  if(cl=="lm"){
    pred<-predict(m,newdata = new_dat,se.fit=TRUE)
  }
     
  if(cl=="glm" | cl=="negbin"){
    #predicted values on the link scale
    pred<-predict(m,newdata=new_dat,type="link",se.fit=TRUE)
  }
  if(cl=="glmerMod" | cl=="lmerMod"){
    pred<-list(fit=predict(m,newdata=new_dat,type="link",re.form=~0))
    #for bootstrapped CI
    new_dat<-cbind(new_dat,rep(0,dim(new_dat)[1]))
    names(new_dat)[dim(new_dat)[2]]<-as.character(formula(m)[[2]])
    mm<-model.matrix(formula(m,fixed.only=TRUE),new_dat)
  }
  #average over potential categorical variables  
  avg_over <- 0 #for cases where no averaging is to be done
  if(length(name_f)>0){
    if(cl=="glmerMod" | cl=="lmerMod"){
      coef_f<-lapply(name_f,function(x) fixef(m)[grep(paste0("^",x),names(fixef(m)))])
    }
    else{
      coef_f<-lapply(name_f,function(x) coef(m)[grep(paste0("^",x),names(coef(m)))])
    }    
    avg_over <- sum(unlist(lapply(coef_f,function(x) mean(c(0,x))))) #averging out all factor effects
    pred$fit<-pred$fit + avg_over
  }
    
  #to get the back-transform values get the inverse link function
  linkinv<-family(m)$linkinv
     
  #get the back transformed prediction together with the 95% CI for LM and GLM
  if(cl=="glm" | cl=="lm" | cl=="negbin"){
    pred$pred<-linkinv(pred$fit)
    pred$LC<-linkinv(pred$fit-1.96*pred$se.fit)
    pred$UC<-linkinv(pred$fit+1.96*pred$se.fit)
  }
     
  #for (G)LMM need to use either bootstrapped CI or use approximate
  #standard error from the variance-covariance matrix
  #see ?predict.merMod and http://glmm.wikidot.com/faq#predconf
  #note that the bootstrapped option is recommended by the lme4 authors
  if(cl=="glmerMod" | cl=="lmerMod"){
    pred$pred<-linkinv(pred$fit)
    if(boot_mer){
      predFun<-function(.) mm%*%fixef(.)+avg_over
      bb<-bootMer(m,FUN=predFun,nsim=200,parallel="multicore",ncpus=n_core) #do this 200 times
      bb$t<-apply(bb$t,1,function(x) linkinv(x))
      #as we did this 200 times the 95% CI will be bordered by the 5th and 195th value
      bb_se<-apply(bb$t,1,function(x) x[order(x)][c(5,195)])
      pred$LC<-bb_se[1,]
      pred$UC<-bb_se[2,] 
    }
    else{
      se <- sqrt(diag(mm %*% tcrossprod(vcov(m),mm)))
      pred$LC <- linkinv(pred$fit - 1.96 * se)
      pred$UC <- linkinv(pred$fit + 1.96 * se)
    }
  }
     
  #the output
  out<-as.data.frame(cbind(new_dat[,1:(length(inter_var)+1)],pred$LC,pred$pred,pred$UC))
  names(out)<-c(names(new_dat)[1:(length(inter_var)+1)],"LC","Pred","UC")
  return(out)
}

pred<-plot_fit(model.acc.logit2,focal_var = "Coh",inter_var = "Speed",RE = "SubID")
pred <- df_child %>% 
  group_by(SubID, Speed, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot) 
plot(Pct.Corr*100~Coh,df_p1_c_acc_speed_coh,col=c("red","blue")[df_p1_c_acc_speed_coh$Speed],pch=16,xlab="Coherence level",ylab="Percentage of Correct response (%)")
lines(pred$Speed[1:20], pred$Pred[1:20],col="red",lwd=3)
lines(LC~C,pred[1:20,],col="red",lwd=2,lty=2)
lines(UC~C,pred[1:20,],col="red",lwd=2,lty=2)
lines(Pred~C,pred[21:40,],col="green",lwd=3)
lines(LC~C,pred[21:40,],col="green",lwd=2,lty=2)
lines(UC~C,pred[21:40,],col="green",lwd=2,lty=2)
lines(Pred~C,pred[41:60,],col="blue",lwd=3)
lines(LC~C,pred[41:60,],col="blue",lwd=2,lty=2)
lines(UC~C,pred[41:60,],col="blue",lwd=2,lty=2)
legend("topleft",legend = c("Low-speed optic flow", "high-speed optic flow"),col=c("red","blue"),pch=16,lwd=3,title = "N addition",bty="n")
## using ggplot to plot
p <- ggplot(data =  df_p1_c_acc_speed_coh, 
       aes(y = Pct.Corr*100, x = Coh, color = Speed, group = Speed) ) + 
    geom_point() +
  geom_line(data=pred[1:20,], aes(x=Coh, y = Pred*100), color= "red") + 
  geom_line(data=pred[21:40,], aes(x=Coh,Pred*100), color = "blue") 
p
```


```{r plot-acc-coh-speed}
df_child$Coh<-factor(df_child$Coh)
df_p2_c_acc_speed_coh <- df_child %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(SubID, Speed, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(Speed, Coh) %>%
  mutate(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.ci = 1.96*100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem

p2_c_acc_speed_coh <- 
  ggplot(data=df_p2_c_acc_speed_coh, aes(x=Coh, y=Pct.Corr.mean, fill = factor(Speed)) , width = 0.1) +
  geom_bar(stat="identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.ci, ymax = Pct.Corr.mean + Pct.Corr.ci), width=.1,position=position_dodge(.9)) +
  ggtitle("Speed X Coherence Interaction in Children") +
  xlab("Coherence") +
  coord_cartesian(ylim=c(65,100)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  ylab("Mean Accuracy (%)") +
  scale_fill_viridis(discrete=TRUE) +   
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_c_acc_speed_coh
ggsave("~/R/moco-psychophysics/analysis/pub_image/1_c_acc_speed_coh.pdf", p2_c_acc_speed_coh, width=12, height=10)
```
```{r}
library(viridis)
df_p2_c_acc_speed_coh$Coh<-factor(df_p2_c_acc_speed_coh$Coh, levels=c("0.15","0.3","0.45","0.6"), labels=c("5%","10%","15%","20%"))
p1<-ggplot(df_p2_c_acc_speed_coh, aes(x = Coh, y = Pct.Corr*100, color = Speed),  alpha = 0.1) + geom_point(data = df_p2_c_acc_speed_coh, aes(x = Coh, y = Pct.Corr.mean, color = Speed), size = 3, position = position_dodge(0.8)) + geom_errorbar(aes(ymin=Pct.Corr.mean-Pct.Corr.ci,ymax=Pct.Corr.mean+Pct.Corr.ci, color = Speed), position = position_dodge(0.8), width = .5) + geom_jitter(position=position_dodge(0.8)) +
  ggtitle("Speed X Coherence Interaction in Children") +
  xlab("Coherence") +
 # coord_cartesian(ylim=c(65,100)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  ylab("Mean Accuracy (%)") +
  scale_color_viridis(discrete=TRUE) +
#  theme(legend.title=element_blank())
  theme(legend.position=c(0.87,0.18)) +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
p1
ggsave("~/R/moco-psychophysics/analysis/pub_image/8_c_acc_speed_coh.pdf", p1, width=12, height=10)
```

```{r plot-acc-coh-pattern}
df_p2_c_acc_pattern_coh <- df_child %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(SubID, PatternType, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(PatternType, Coh) %>%
  summarize(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.ci = 1.96*100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_c_acc_pat_coh <- 
  ggplot(data=df_p2_c_acc_pattern_coh, aes(x=Coh, y=Pct.Corr.mean, fill = factor(PatternType)) , width = 0.1) +
  geom_bar(stat="identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.ci, ymax = Pct.Corr.mean + Pct.Corr.ci), width=.02,position=position_dodge(.14)) +
  ggtitle("Pattern X Coherence Interaction in Children") +
  ylab("Percentage of Accuracy (%)") +
  xlab("Coherence levels") +
  coord_cartesian(ylim=c(62,100)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  scale_colour_brewer(palette = "Set1")  +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_c_acc_pat_coh
```
```{r plot-acc-gen-pat}
df_p2_c_acc_gen_pat <- df_child %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(SubID, Gender, PatternType) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(PatternType, Gender) %>%
  summarize(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.ci = 1.96*100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_c_acc_gen_pat <- 
  ggplot(data=df_p2_c_acc_gen_pat, aes(x=Gender, y=Pct.Corr.mean, fill = factor(PatternType)) , width = 0.1) +
  geom_bar(stat="identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.ci, ymax = Pct.Corr.mean + Pct.Corr.ci), width=.1,position=position_dodge(.9)) +
  ggtitle("The Accuracy in Children by Gender and Pattern") +
  ylab("Percentage of Accuracy (%)") +
  xlab("Gender") +
  coord_cartesian(ylim=c(65,100)) +
  theme_bw() +
  theme.custom + # Position legend in bottom right
  scale_colour_brewer(palette = "Set1")  +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_c_acc_gen_pat
```
```{r plot-acc-age-speed}
df_p3_c_acc_speed_age <- df_child %>% 
  # filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(SubID, Speed, Age) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr.mean = 100*N.corr/N.tot)  
p4_c_acc_speed_age <- ggplot(data =  df_p3_c_acc_speed_age, 
       aes(y = Pct.Corr.mean, x = Age, color = Speed, group = Speed) ) + 
    geom_point() +
    geom_smooth() +
    ggtitle("Speed X Age Interaction in Children") +
    xlab("Age") +
 #   coord_cartesian(ylim=c(65,100)) +
    theme_bw(base_size = 18) +
  #  theme.custom + # Position legend in bottom right
    ylab("Mean Accuracy (%)") +
    scale_color_viridis(discrete=TRUE) +   
    theme(legend.position=c(0.9,0.17)) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
 # geom_line(df_p4_c_acc_speed_age, aes(x=Coh, y = Pred*100), color= "red") + 
 #  geom_line(data=pred[21:40,], aes(x=Coh,Pred*100), color = "blue") 
p4_c_acc_speed_age
# ggsave("~/R/moco-psychophysics/analysis/pub_image/2_c_acc_speed_age.pdf", p4_c_acc_speed_age, width=12, height=10)
```
```{r}
df_p4_c_acc_speed_age <-df_p3_c_acc_speed_age  %>% 
  group_by(Speed, Age) %>%
  summarize(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.ci = 1.96*100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem

p2_c_acc_speed_coh <- 
  ggplot(data=df_p2_c_acc_speed_coh, aes(x=Coh, y=Pct.Corr.mean, fill = factor(Speed)) , width = 0.1) +
  geom_bar(stat="identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.ci, ymax = Pct.Corr.mean + Pct.Corr.ci), width=.1,position=position_dodge(.9)) +
  ggtitle("Speed X Coherence Interaction in Children") +
  ylab("Percentage of Accuracy (%)") +
  xlab("Coherence levels") +
  coord_cartesian(ylim=c(65,100)) +
  theme_bw() +
  theme.custom + # Position legend in bottom right
  scale_colour_brewer(palette = "Set1")  +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_c_acc_speed_coh
```





```{r rt-interaction-full, eval=FALSE}
df_child$RT[which(df_child$RT==0 & df_child$Acc==FALSE)] <- NA
form.log.rt<- log(RT) ~  Age+ Gender +Acc+ Coh*Speed*PatternType + (1|SubID)
model.log.rt <- lmer(formula = form.log.rt, data = df_child,control=lmerControl(),na.action=na.exclude, REML=FALSE)
summary(model.log.rt) #AIC 8858
car::Anova(model.log.rt) # in package car
```
```{r rt-interaction-full, eval=FALSE}
form.log.rt1<- log(RT) ~  Age+ Gender + Acc+Age*Coh+Age*Speed+Age*PatternType + Gender*Coh+Gender*Speed+Gender*PatternType+ (1|SubID)
model.log.rt1 <- lmer(formula = form.log.rt1, data = df_child, REML=FALSE)
summary(model.log.rt1) #AIC 8858
car::Anova(model.log.rt1) # in package car
anova(model.log.rt1, model.log.rt)
```

```{r rt-interaction-full, eval=FALSE}
form.log.rt2<- log(RT) ~  Age + Acc+ Coh+ Speed+PatternType+ Age*Speed+ Gender*Coh+ (1|SubID)
model.log.rt2 <- lmer(formula = form.log.rt2, data = df_child, REML=FALSE)
summary(model.log.rt2) #AIC 8794
car::Anova(model.log.rt2,type=3) # in package car
```
```{r get-df}
# get df. One way afex does not work for glmer, try lmer to get df, which should be the same as the glmer
afex::mixed(log(RT) ~  Age + Acc+ Coh+ Speed+PatternType+ Age*Speed+ Gender*Coh+ (1|SubID) , data=df_child, method = "S",  control = lmerControl(optCtrl = list(maxfun = 1e6)))
```
```{r get-95%CI&OR-child}
se <- sqrt(diag(vcov(model.log.rt2)))
# table of estimates with 95% CI
tab <- cbind(OR = fixef(model.log.rt2), LL = fixef(model.log.rt2) - 1.96 * se, UL = fixef(model.log.rt2) + 1.96 * se)
# however, this result is different from the below
print(exp(tab), digits=3)

# confidence
cc <- confint(model.log.rt2)  ## slow (~ 11 seconds) 
exp(cc)
r2glmm::r2beta(model.log.rt2, method = 'kr', partial = T)
# effect size eta
afex::aov
lmerTest::
```

#### Plot of speed across patterns by age
```{r rt-by-speed_pattern-age-plot}
df_p1_c_rt <- df_child %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(PatternType,Speed,Coh, AgeYrs) %>% 
  summarize(n=length(RT),
            RT.mean=mean(RT, na.rm = T),
            RT.ci=1.96*sd(RT, na.rm = T)/sqrt(length(RT)))

df_p1_c_rt2 <- df_child %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(SubID, Age, Gender, AgeYrs, PatternType, Speed, Coh) %>% 
  summarize( RT.bysub=mean(RT, na.rm = T))%>%
    group_by(PatternType,Speed,Coh, AgeYrs) %>%
    summarize( n=n(),
               RT.mean =  mean(RT.bysub, na.rm=TRUE),
               RT.ci = 1.96*sd(RT.bysub, na.rm=TRUE)/sqrt(length(RT.bysub)))  # mean is the same, however the se is different.
limits = aes( ymax = RT.mean + RT.ci , ymin = RT.mean - RT.ci )
p1_c_rt <- 
  ggplot(data=df_p1_c_rt2 , aes(x=Coh, y=RT.mean, color = AgeYrs) ) +
  facet_grid( facets = PatternType ~ Speed ) +
  geom_line() +
  geom_pointrange(limits) +
  xlim(0.15,0.60) +
  ylim(1.1, 5.1) +
  ylab("Reaction times (s)") +
  xlab("Coherence level") +
  theme_bw() +
  theme.custom +
  scale_colour_brewer(palette = "Set1") + 
  scale_x_continuous(breaks=seq(0.15, 0.60, 0.15))
  # geom_hline(yintercept=0.5, linetype="dashed")
p1_c_rt

```
```{r plot-rt-coh-speed}
df_p2_c_rt_speed_coh <- df_child %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
  group_by(SubID, Speed, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(Speed, Coh) %>%
  summarize(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.ci = 1.96*100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_c_rt_speed_coh <- 
  ggplot(data=df_p2_c_rt_speed_coh, aes(x=Coh, y=Pct.Corr.mean, fill = factor(Speed)) , width = 0.1) +
  geom_bar(stat="identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.ci, ymax = Pct.Corr.mean + Pct.Corr.ci), width=.1,position=position_dodge(.9)) +
  ggtitle("Speed X Coherence Interaction in Children") +
  ylab("Percentage of Accuracy (%)") +
  xlab("Coherence levels") +
  coord_cartesian(ylim=c(65,100)) +
  theme_bw() +
  theme.custom + # Position legend in bottom right
  scale_colour_brewer(palette = "Set1")  +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_c_rt_speed_coh
```














# adult data
### it is the data exclude subj 14
#Generalized linear mixed effects model with a probit link/ logit link/ weibull model
Generalized linear mixed effects model 
The level 1 (i) is accuracy/RT in each condition for each subject. The level 2 (j) is each subject. The random effects in this model are SubID, Gender and AgeYrs. Fixed effects are Speed, PatternType, Coh, and their interaction
$Y_{i,j}=B_{0j} + B_{1j}*PatternType_{ij}+B_{2j}*Speed_{ij}+B_{3j}*Coh_{ij}+e_{ij}$
$B_{0,j} = r_{00}+ r_{01}*AgeYrs_{j}+r_{02}*Gender_{j}+u_{0j}$
$B_{1,j} = r_{10}+u_{1j}$
$B_{2j} = r_{20}+u_{2j}$
$B_{3j} = r_{30}+u_{3j}$

## Accuracy 
df_adult$Speed <- factor(df_adult$Speed, labels = c("2 deg/s", "8 deg/s"))
df_adult$SubID <- factor(df_adult$SubID)
Rescale and center continuous parameters
df_adult$Coh_scaled<- scale(df_adult[,7])
df_adult$Age_scaled<- scale(df_adult[,8])

df2$Age <- factor(df2$Age,ordered = FALSE) # the variables can not be ordinal, it will have L, C, Q
### probit link function
#### Empty model
```{r acc-probit-empty, eval=FALSE}
form.empty <- Acc~(1|SubID)
model.acc.empty <- glmer(formula = form.empty, family=binomial(mafc.probit(2)), data = df_adult)
summary(model.acc.empty)
```

```{r ICC-Acc, eval=FALSE}
ICC_Acc <-
The result is the same as the uncleaned one

```
ICC is small (14%)
#### full model with random intercept
```{r acc-probit-without-Gender-Age, eval=FALSE}
form.fixed <- Acc ~ Coh + Speed + PatternType  + (1|SubID)
model.acc.fixed <- glmer(formula = form.fixed, family=binomial(mafc.probit(2)), data = df_adult)
summary(model.acc.fixed) # AIC 9434
```

#### full model with random intercept and random slope
```{r acc-probit-random-slope-gender, eval=FALSE}
form.gender<- Acc ~ Coh + Speed + PatternType + (Gender|SubID)
model.acc.gender<- glmer(formula = form.gender, family=binomial(mafc.probit(2)), data = df2,
                         control=glmerControl(optimizer="bobyqa",
                          optCtrl=list(maxfun=1000000)) ) #AIC 9429
anova(model.acc.gender,model.acc.fixed)   # better fit
form.age <- Acc ~ Coh + Speed + PatternType + (Age|SubID)
model.acc.age <- glmer(formula = form.age, family=binomial(mafc.probit(2)), data = df2) #AIC 
form.coh<- Acc ~ Coh + Speed + PatternType + (Coh|SubID)
model.acc.coh<- glmer(formula = form.coh, family=binomial(mafc.probit(2)), data = df2 ) #AIC 9424 better fit
form.speed <- Acc ~ Coh + Speed + PatternType + (Speed|SubID)
model.acc.speed <- glmer(formula = form.speed, family=binomial(mafc.probit(2)), data = df2) #AIC 9338, better fit
form.pattern <- Acc ~ Coh + Speed + PatternType + (PatternType|SubID)
model.acc.pattern <- glmer(formula = form.pattern, family=binomial(mafc.probit(2)), data = df2) #AIC 9395.5, better fit
anova(model.acc.fixed,model.acc.coh)
anova(model.acc.fixed,model.acc.speed)
anova(model.acc.fixed,model.acc.pattern)
```
AIC does not decrease in the random slope model of age and 

####  gender as fixed effect
```{r acc-probit-full, eval=FALSE}
form_a.full <- Acc ~ Coh + Speed + PatternType + Gender + (1|SubID)
model_a.acc.full <- glmer(formula = form_a.full, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_adult)
summary(model_a.acc.full) # AIC 9414
anova(model_a.acc.fixed,model.acc.full)  # significant
anova(model_a.acc.full)
```
#### interaction effect
```{r acc-probit-interaction, eval=FALSE}
form_a.full1<- Acc ~  Gender+scale(Coh)+Speed+PatternType + scale(Coh)*Speed*PatternType + (1|SubID)
model_a.acc.full1 <- glmer(formula = form_a.full1, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 200000)),  data = df_adult)
summary(model_a.acc.full1)
 # AIC 9351.8
# Model failed to converge
```

```{r acc-probit-interaction-gender-age, eval=FALSE}
form_a.full3<- Acc ~ scale(Coh) + Speed + PatternType + Gender + scale(Coh)*PatternType + Gender*scale(Coh) + Gender*Speed + Gender*PatternType+ (1|SubID)
model_a.acc.full3 <- glmer(formula = form_a.full3, family=binomial(mafc.probit(2)),glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),  data = df_adult) # AIC 9359.9
summary(model_a.acc.full3)
```
```{r acc-probit-interaction-gender-coh, eval=FALSE}
form_a.probit<- Acc ~ scale(Coh) + PatternType + Speed + PatternType*scale(Coh) + Speed*scale(Coh)+Gender*Speed + Gender*PatternType+ (1|SubID)
model_a.acc.probit <- glmer(formula = form_a.probit, family=binomial(mafc.probit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)),  data = df_adult)
summary(model_a.acc.probit)
anova(model_a.acc.full3,model_a.acc.probit)  # 9356.9, better fit
```
# ##### bumped up max number of iterations.
#  ss <- getME(model.acc.full,c("theta","fixef"))
# <!-- m2 <- update(model.acc.full,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4))) -->
# still failed,  Try a different optimizer
# 
# ```{r find-optimizer}
# model.acc.full.new <- update(model.acc.full,start=ss,control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# summary(model.acc.full.new)

### logit link function
```{r acc-logit-interaction, eval=FALSE}
model_a.acc.logit <- glmer(formula = form_a.probit, family=binomial(mafc.logit(2)), data = df_adult)
summary(model_a.acc.logit) # better fit than probit
car::Anova(model_a.acc.logit)
anova(model_a.acc.logit,model_a.acc.probit)
anova(model_a.acc.logit,model_a.acc.logit1)

form_a.probit1<- Acc ~ scale(Coh) + PatternType + Speed + Age+ PatternType*scale(Coh) + Gender*Speed + Gender*PatternType+ (1|SubID)
model_a.acc.logit1 <- glmer(formula = form_a.probit1, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_adult)
summary(model_a.acc.logit1)
car::Anova(model_a.acc.logit1, type =3)
anova(model_a.acc.logit1)
# ss <- getME(model.cloglog.interaction,c("theta","fixef"))
# m2 <- update(model.cloglog.interaction,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4)))
```
lmerTest::anova(model_a.acc.logit2)
MuMIn::r.squaredGLMM(model.acc.logit2) # ICC?
MuMIn::r.squaredLR(model.acc.logit2)
MuMIn::r.squaredLR(model.acc.logit2,null.RE = TRUE) 
# (R2m <- Vf / (Vtotal))
# (R2c <- (Vf + Vr) / (Vtotal))
effsize::cohen.d(df2$Acc ~ Gender+ Coh + Speed + PatternType + Coh*Speed + +Age*Speed + Age*PatternType + (1|SubID))
aod::wald.test(b = coef(model.acc.logit), Sigma = vcov(model.logit.interaction), Terms = 4:6)
pbkrtest::KRmodcomp(model_a.acc.logit2)
```{r calculate_r^2_ICC}
# calculate the marginal R^2 and conditional R^2
MuMIn::r.squaredGLMM(model_a.acc.logit)

# for binomial response data
#compute the marginal R-square
#compute the variance in the fitted values
VarF <- var(as.vector(fixef(model_a.acc.logit) %*% t(model_a.acc.logit@pp$X)))
# VarCorr() extracts variance components
# attr(VarCorr(lmer.model),’sc’)^2 extracts the residual variance, VarCorr()$plot extract the variance of the plot effect
VarF/(VarF + VarCorr(model_a.acc.logit)[[1]][1] + attr(VarCorr(model_a.acc.logit), 'sc')^2 + (pi^2)/3)

#compute the conditionnal R-square
(VarF + VarCorr(model_a.acc.logit)[[1]][1])/(VarF + VarCorr(model_a.acc.logit)[[1]][1] + (attr(VarCorr(model_a.acc.logit), 'sc')^2) + (pi^2)/3)
# The residual deviance in logistic regression is fixed to (pi ^ 2) / 3

# ICC
# extracting tau^2 for the varying intercept
tau2 <- brms::VarCorr(model_a.acc.logit)[[1]][1]^2

# computing the ICC for the intercept
ICC1 <- tau2 / (tau2 + (pi^2 / 3) )
ICC1
# other
performance::icc(model_a.acc.logit)
# actually ICC is not valid for logistic regression
```

```{r get-df}
# get df. One way afex does not work for glmer, try lmer to get df, which should be the same as the glmer
model_a.acc.logit_lmer <- lmer(formula = model_a.acc.logit,  data = df_adult)
summary(model_a.acc.logit_lmer)
anova(model_a.acc.logit_lmer)
```
```{r post-hoc}
lsmeans::lsmeans(model_a.acc.logit1, pairwise~Gender*Speed, adjust="tukey")
lsmeans::lsmeans(model_a.acc.logit1, pairwise~Gender*PatternType, adjust="tukey")
lsmeans::lsmeans(model_a.acc.logit1, pairwise~Coh*PatternType, adjust="tukey")
library(emmeans)
emmeans(model_a.acc.logit1, specs = pairwise ~ Gender:Speed, type = "response", adjust = "none")
emmeans(model_a.acc.logit1, specs = pairwise ~ Gender:PatternType, type = "response", adjust = "none")
```
```{r get-95%CI&OR-child}
# Way 1
se_a <- sqrt(diag(vcov(model_a.acc.logit1)))
# table of estimates with 95% CI
tab_a <- cbind(OR = fixef(model_a.acc.logit1), LL = fixef(model_a.acc.logit1) - 1.96 * se_a, UL = fixef(model_a.acc.logit1) + 1.96 * se_a)
# however, this result is different from the below
print(exp(tab_a), digits=3)

# way 2
cc_a <- confint(model_a.acc.logit)  ## slow (~ 11 seconds)
# get oR and 95% CI
ctab_a <- cbind(OR=fixef(model_a.acc.logit),cc_a)
# Exponentiate to get odds ratios:
rtab_a <- exp(ctab_a)
print(rtab_a,digits=5)
# if with scale
# sd of coh

sd<-sd(df_adult$Coh)
ctab_a <- cbind(OR=fixef(model_a.acc.logit)/sd,cc_a/sd)
# Exponentiate to get odds ratios:
rtab_a <- exp(ctab_a)
print(rtab_a,digits=5)
# 2 way is slightly different

# If I want to use this model for inference I need to unstandardize the coefficients before reporting them to make them more easily interpretable.

#way 3
jtools::summ(model_a.acc.logit, scale=TRUE, confint = TRUE,exp = TRUE, digits = 5)
# I feel this does not work

# way 4
# The first step in the process is to get the standardized estimates and confidence intervals from the model. I use tidy() from package broom for this, which returns a data.frame of coefficients, statistical tests, and confidence intervals. 
library(broom)
coef_st = tidy(model_a.acc.logit, effects = "fixed",
     conf.int = TRUE,
     conf.method = "profile")
sd_all = map( select(df_adult, Coh), sd) %>% 
     stack() %>%
     mutate(ind = 'scale(Coh)')
coef_unst_Coh = coef_st[2,] %>%
     inner_join(., sd_all, by = c("term" = "ind") ) %>%
     mutate_at( vars(estimate, conf.low, conf.high), funs(round( ./values, 4) ) ) 

## Further explanation of confint
### obtain confidence intervals for the coefficient estimates
confint(model.acc.logit2) 
# get the exact 95% confidence interval for the coefficients b
exp(confint(model.acc.logit2))
## use the parametric bootstrap to calculate confidence intervals
confint(model.acc.logit2, method="boot", nsim=1000, parm=1:3)
```
<!-- wald.test(b = coef(model.logit.interaction), Sigma = vcov(model.logit.interaction), Terms = 4:6) -->
AIC 5715, smaller AIC

``` {r acc-post-hoc}
# contrast within factor: pairwise comparison
# emeans cannot be installed in this r version
# check https://aosmith.rbind.io/2019/03/25/getting-started-with-emmeans/
library(emmeans)
emmeans(model.acc.logit2, Acc ~ gender)
emm1.1<-emmeans(fit1, specs = pairwise ~ f1:f2, type = "response", adjust = "none")
emm1.1$contrasts %>%
     confint()
emm2 = emmeans(fit1, specs = pairwise ~ f1|f2, type = "response")
emm2

# way 1
library(multcomp)
summary(glht(model.acc.logit2, mcp(Gender="Tukey")))
summary(glht(model.acc.logit2, mcp(Coh="Tukey")))
```
```{r acc-cloglog-interaction, eval=FALSE}
model_a.acc.cloglog <- glmer(formula = form_a.probit1, family=binomial(mafc.cloglog(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun =200000)), data = df_adult)
summary(model_a.acc.cloglog)
anova(model_a.acc.logit,model_a.acc.cloglog)
# ss <- getME(model.cloglog.interaction,c("theta","fixef"))
# m3 <- update(model.cloglog.interaction,start=ss,control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# summary(m3)
```
AIC 5768

```{r acc-weibull-interaction, eval=FALSE}
model_a.acc.weibull <- glmer(formula = form_a.probit1, family=binomial(mafc.weib(2)), data = df_adult)
summary(model_a.acc.weibull)
anova(model_a.acc.logit,model_a.acc.weibull)
```

```{r plot-sensitivity}
# It is important to check that your model is not influenced by one or a small set of observations. This might indicate your model is over fit or that your model is sensitive to the particular observations included in the model.
ggplot(data.frame(lev=hatvalues(model.fixed.rt2),pearson=residuals(model.fixed.rt2,type="pearson")),
      aes(x=lev,y=pearson)) +
    geom_point() +
    theme_bw()

# The following code determines which of the observations have the highest leverage and displays these observations. The code also generates a new model without these observations and then compares the coefficients for the will all observations to this new model with some observations removed.
# levId <- which(hatvalues(mm) >= .172)
# pbDat[levId,c("y","x1","x2","g1")]
# summary(pbDat[,c("y","x1","x2")])
# 
# mmLev <- lmer(y ~ x1 + x2 + (1|g1), data=pbDat[-c(levId),])
# mmLevCD <- data.frame(effect=fixef(mm),
#                      change=(fixef(mmLev) - fixef(mm)),
#                      se=sqrt(diag(vcov(mm)))
#                      )
# rownames(mmLevCD) <- names(fixef(mmLev))
# mmLevCD$multiples <- abs(mmLevCD$change / mmLevCD$se)
# mmLevCD
```

### plotting
#### Plot of Coh across patterns by age
```{r plot-acc-coh-pattern}
df_p2_a_acc_coh_pat <- df_adult %>% 
  group_by(SubID, PatternType, Coh) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(Coh, PatternType) %>%
  mutate(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.ci = 1.96*100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_a_acc_pat_coh <- 
  ggplot(data=df_p2_a_acc_coh_pat, aes(x=factor(Coh), y=Pct.Corr.mean, fill = factor(PatternType)) , width = 0.1) +
  geom_bar(stat="identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.sem, ymax = Pct.Corr.mean + Pct.Corr.sem), width=.1,position=position_dodge(.9)) +
  ggtitle("Pattern X Coherence Interaction in Adults") +
  ylab("Mean Accuracy (%)") +
  xlab("Coherence") +
  coord_cartesian(ylim=c(45,100)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  scale_fill_viridis(discrete=TRUE) +
  theme(legend.position=c(0.15,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_a_acc_pat_coh
ggsave("~/R/moco-psychophysics/analysis/pub_image/3_a_acc_pat_coh.pdf", p2_a_acc_pat_coh, width=12, height=10)
```
```{r}
library(viridis)
 df_p2_a_acc_coh_pat$Coh<-factor(df_p2_a_acc_coh_pat$Coh, levels=c("0.05","0.1","0.15","0.2"), labels=c("5%","10%","15%","20%"))
p2<-ggplot(df_p2_a_acc_coh_pat, aes(x = Coh, y = Pct.Corr*100, color = PatternType),  alpha = 0.1) + geom_point(data = df_p2_a_acc_coh_pat, aes(x = Coh, y = Pct.Corr.mean, color = PatternType), size = 4, position = position_dodge(0.8)) + geom_errorbar(aes(ymin=Pct.Corr.mean-Pct.Corr.ci,ymax=Pct.Corr.mean+Pct.Corr.ci, color = PatternType), position = position_dodge(0.8), width = .5) + geom_jitter(position=position_dodge(0.8)) +
  ggtitle("Pattern X Coherence Interaction in Adults") +
  xlab("Coherence") +
#  coord_cartesian(xlim=c(0,0.2)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  ylab("Mean Accuracy (%)") +
  scale_color_viridis(discrete=TRUE) +
#  theme(legend.title=element_blank())
  theme(legend.position=c(0.90,0.14)) +
  theme(plot.title = element_text(hjust = 0.5)) +
#  scale_x_discrete(labels = c("0.05","0.10","0.15","0.20"))+ 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
p2
ggsave("~/R/moco-psychophysics/analysis/pub_image/9_a_acc_coh_pat.pdf", p2, width=12, height=10)
```
```{r plot-acc-speed-gender}
df_p2_a_acc_speed_gender <- df_adult %>% 
  group_by(SubID, Speed, Gender) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(Speed, Gender) %>%
  mutate(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.ci = 1.96*100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_a_acc_speed_gen <- 
  ggplot(data=df_p2_a_acc_speed_gender, aes(x=factor(Speed), y=Pct.Corr.mean, fill = factor(Gender)) ) +
  geom_bar(stat="identity", position = position_dodge(), width = 0.5) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.sem, ymax = Pct.Corr.mean + Pct.Corr.sem), width=.1,position=position_dodge(.5)) +
  ggtitle("Speed X Gender Interaction in Adults") +
  ylab("Mean Accuracy (%)") +
  xlab("Optic flow Speed") +
  coord_cartesian(ylim=c(40,100)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  scale_fill_viridis(discrete=TRUE) +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_a_acc_speed_gen 
ggsave("~/R/moco-psychophysics/analysis/pub_image/4_a_acc_speed_sex.pdf", p2_a_acc_speed_gen, width=12, height=10)
```
```{r}
p3<-ggplot(df_p2_a_acc_speed_gender, aes(x = Speed, y = Pct.Corr*100, color = Gender),  alpha = 0.1) + geom_point(data = df_p2_a_acc_speed_gender, aes(x = Speed, y = Pct.Corr.mean, color = Gender), size = 4, position = position_dodge(0.8)) + geom_errorbar(aes(ymin=Pct.Corr.mean-Pct.Corr.ci,ymax=Pct.Corr.mean+Pct.Corr.ci, color = Gender), position = position_dodge(0.8), width = .5) + geom_jitter(position=position_dodge(0.8)) +
   ggtitle("Speed X Gender Interaction in Adults") +
  ylab("Mean Accuracy (%)") +
  xlab("Optic flow Speed") +
#  coord_cartesian(xlim=c(0,0.2)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  scale_color_viridis(discrete=TRUE) +
#  theme(legend.title=element_blank())
  theme(legend.position=c(0.90,0.14)) +
  theme(plot.title = element_text(hjust = 0.5))+ theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
#  scale_x_discrete(labels = c("0.05","0.10","0.15","0.20"))
p3
ggsave("~/R/moco-psychophysics/analysis/pub_image/10_a_acc_speed_sex.pdf", p3, width=12, height=10)
```
```{r plot-acc-gen-pattern}
df_p2_a_acc_gen_pat <- df_adult %>% 
  group_by(SubID, PatternType, Gender) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(Gender, PatternType) %>%
  mutate(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.ci = 1.96*100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_a_acc_pat_gen <- 
  ggplot(data=df_p2_a_acc_gen_pat, aes(x=factor(PatternType), y=Pct.Corr.mean, fill = factor(Gender)) ) +
  geom_bar(stat="identity", position = position_dodge(), width = 0.5) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.sem, ymax = Pct.Corr.mean + Pct.Corr.sem), width=.1,position=position_dodge(.5)) +
  ggtitle("Pattern X Gender Interaction in Adults") +
  ylab("Mean Accuracy (%)") +
  xlab("Optic flow Pattern Type") +
  coord_cartesian(ylim=c(45,100)) +
  theme_bw(base_size = 18) +
# theme.custom + # Position legend in bottom right
  scale_fill_viridis(discrete=TRUE) +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
p2_a_acc_pat_gen
ggsave("~/R/moco-psychophysics/analysis/pub_image/5_a_acc_pat_sex.pdf", p2_a_acc_pat_gen, width=12, height=10)
```

```{r}
p4<-ggplot(df_p2_a_acc_gen_pat, aes(x = PatternType, y = Pct.Corr*100, color = Gender),  alpha = 0.1) + geom_point(data = df_p2_a_acc_gen_pat, aes(x = PatternType, y = Pct.Corr.mean, color = Gender), size = 4, position = position_dodge(0.8)) + geom_errorbar(aes(ymin=Pct.Corr.mean-Pct.Corr.ci,ymax=Pct.Corr.mean+Pct.Corr.ci, color = Gender), position = position_dodge(0.8), width = .5) + geom_jitter(position=position_dodge(0.8)) +
   ggtitle("Pattern X Gender Interaction in Adults") +
  ylab("Mean Accuracy (%)") +
  xlab("Optic flow Pattern Type") +
#  coord_cartesian(xlim=c(0,0.2)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  scale_color_viridis(discrete=TRUE) +
#  theme(legend.title=element_blank())
  theme(legend.position=c(0.90,0.14)) +
  theme(plot.title = element_text(hjust = 0.5)) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
#  scale_x_discrete(labels = c("0.05","0.10","0.15","0.20"))
p4
ggsave("~/R/moco-psychophysics/analysis/pub_image/11_a_acc_pat_sex.pdf", p4, width=12, height=10)
```

### Plot of actual  *p*(corr) and predicted *p*(corr) by condition
```{r p-corr-pattern-speed-plot-final, include=TRUE}
df.bysub.bycond %>% 
  group_by( Gender,Coh,Speed,PatternType) %>% 
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean)) -> 
  df.bygender.bycond
# add fitted line
xseq<-seq(0.05,0.2,len=100)
df.bysub.bycond$id<-with(df.bysub.bycond,interaction(Speed, PatternType,Gender, SubID))
nd<-data.frame(rep(xseq,8*29),id=rep(levels(df.bysub.bycond$id),each=100))
# levels(nd$id)<-levels(df.bysub.byage.bycond$id)
mm <-matrix(unlist(strsplit(as.character(nd$id),"[.]")), ncol=4,byrow=TRUE)
nd$Speed<-gsub("[[:space:]]", "",factor(mm[,1]))
nd$PatternType<-factor(mm[,2])
nd$Gender<-factor(mm[,3])
nd$SubID<-factor(mm[,4])
colnames(nd)[1] <- "Coh"

nd$acc.pred<-predict(model.acc.logit,newdata=nd,type="response",se.fit=TRUE) # obtain predicted values
nd$rt.pred<-exp(predict(model.log.rt2,newdata=nd, type="response", se.fit=TRUE)) # obtain predicted values

nd2 <- nd %>%
  group_by(Gender, Speed,Coh, PatternType) %>%
  summarize(acc.pred.mean=mean(acc.pred),
         acc.pred.se=sd(acc.pred)/sqrt(length(acc.pred)),
         RT.pred.mean=mean(rt.pred),
         RT.pred.se=sd(rt.pred)/sqrt(length(rt.pred)))
df.bygender.bycond$Speed<-factor(df.bygender.bycond$Speed)
# Plot of extual and predicted ACC
title_text <- 'Percentage of correct responses by Coherence, Pattern, and Speed in adult participants'
pic.acc<-ggplot(data=df.bygender.bycond, aes(x=Coh, y=pcorr.mean, color=Gender)) +
  geom_point(aes(group=Gender, color=Gender),size=2) +
  geom_line(data=nd2, aes(x=Coh,y=acc.pred.mean, group=Gender, color=Gender),size=1) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence (%)", y="Percentage of Accuracy") +
  ggtitle(title_text) +
  scale_colour_hue(name="participant gender",    #Legend label, use darker colors
                      breaks=c("Female", "Male"),
                     labels=c("Female", "Male"))+
  theme_bw() +
  theme.custom +
  xlim(0.05, 0.2) +
  geom_hline(yintercept=0.5, linetype="dashed")

pic.acc

# Plot of extual and predicted ACC
title_text <- 'Reaction Times by Coherence, Pattern, and Speed in adult participants'
pic.rt<-ggplot(data=df.bygender.bycond, aes(x=Coh, y=RT.mean.mean, color=Gender)) +
  geom_point(aes(group=Gender, color=Gender),size=2) +
  geom_line(data=nd2, aes(x=Coh,y=RT.pred.mean, group=Gender, color=Gender),size=1) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence (%)", y="Reaction times (s)") +
  ggtitle(title_text) +
  scale_colour_hue(name="participant gender",    #Legend label, use darker colors
                     breaks=c("Female", "Male"),
                     labels=c("Female", "Male"))+
  theme_bw() +
  theme.custom +
  xlim(0.05, 0.2) +
  geom_hline(yintercept=0.5, linetype="dashed")

pic.rt
```
```{r rt-interaction-full, eval=FALSE}
form.log.rt_a<- log(RT) ~  Gender+ Acc+ Coh+ Speed+PatternType+ Coh+ Speed*PatternType*Coh+  (1|SubID)
model.log.rt_a <- lmer(formula = form.log.rt_a, data = df_adult, REML=FALSE)
summary(model.log.rt_a) #AIC 8794
car::Anova(model.log.rt_a,type=3) # in package car
```
```{r rt-interaction-full, eval=FALSE}
form.log.rt1_a<- log(RT) ~  Acc+ Coh+ Speed+Coh*Speed+Coh*PatternType+ Gender*Coh+ Gender*Speed+ Gender*PatternType+ (1|SubID)
model.log.rt1_a <- lmer(formula = form.log.rt1_a, data = df_adult, REML=FALSE)
summary(model.log.rt1_a) #AIC 8794
car::Anova(model.log.rt1_a,type=3) # in package car
```
```{r rt-interaction-full, eval=FALSE}
form.log.rt1_a<- log(RT) ~  Acc+ Coh+ Speed+Coh*Speed+Coh*PatternType+ Gender*Coh+ Gender*PatternType+ (1|SubID)
model.log.rt1_a <- lmer(formula = form.log.rt1_a, data = df_adult, REML=FALSE)
summary(model.log.rt1_a) #AIC 8794
car::Anova(model.log.rt1_a,type=3) # in package car
```
```{r r2_ICC}
# ICC
tau2 <- brms::VarCorr(model.log.rt1_a)[[1]][1]^2

# computing the ICC for the intercept
ICC1 <- tau2 / (tau2 + (pi^2 / 3) )
ICC1
```
```{r get-df}
# get df. One way afex does not work for glmer, try lmer to get df, which should be the same as the glmer
car::Anova(model.log.rt1_a,type=3)
car::Anova(model.log.rt1_a,ddf="Kenward-Roger")
anova(model.log.rt1_a)
afex::mixed(log(RT) ~  Acc+ Coh+ Speed+Coh*Speed+Coh*PatternType+ Gender*Coh+ Gender*PatternType+ (1|SubID) , data=df_adult, method = "S",  control = lmerControl(optCtrl = list(maxfun = 1e6)))
```
```{r get-95%CI&OR-adult}
se <- sqrt(diag(vcov(model.log.rt1_a)))
# table of estimates with 95% CI
tab <- cbind(OR = fixef(model.log.rt1_a), LL = fixef(model.log.rt1_a) - 1.96 * se, UL = fixef(model.log.rt1_a) + 1.96 * se)
# however, this result is different from the below
print(exp(tab), digits=3)
```














#group comparison
# Accuracy group comparison
```{r acc-logit-initial, eval=FALSE}
df_all$Speed <- factor(df_all$Speed, labels = c("Low speed", "High Speed"))
df_all$SubID <- factor(df_all$SubID)
df_all$group <- factor(df_all$group)
form.acc.logit<- Acc ~ Gender + Coh + Speed + PatternType + group + Age+ group*Coh*Speed*PatternType*Gender+(1|SubID) 
model.acc.logit <- glmer(formula = form.acc.logit, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_all1)
summary(model.acc.logit)
form.acc.logit1<- Acc ~ Gender + Coherence + Speed + PatternType + group + Age+ group*Coherence*Speed*PatternType+(1|SubID)
model.acc.logit1 <- glmer(formula = form.acc.logit1, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_all1)
summary(model.acc.logit1)
form.acc.logit<- Acc ~ Gender + Coh + Speed + PatternType + group + Age+ group*Coh+Coh*Speed+group*PatternType+Coh*Pattern+Speed*PatternType+Gender*Coh+(1|SubID) 

car::Anova(model.acc.logit,type=3)
se <- sqrt(diag(vcov(model.acc.logit)))
# table of estimates with 95% CI
tab <- cbind(OR = fixef(model.acc.logit), LL = fixef(model.acc.logit) - 1.96 * se, UL = fixef(model.acc.logit) + 1.96 * se)
# however, this result is different from the below
print(exp(tab), digits=4)
```

```{r get-df}
model.acc.logit_lmer <- lmer(formula = form.acc.logit,  data = df_all)
summary(model.acc.logit_lmer)
anova(model.acc.logit_lmer)
afex::mixed(RT ~ Gender + Coh + Speed + PatternType + group + group*Coh+ group*Speed + (1|SubID) , data=df_all, method = "S",  control = lmerControl(optCtrl = list(maxfun = 1e6)))
```
``` {r mean-sd}
df %>% 
  group_by(Gender, group, SubID) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) -> 
  df4
df.bysub.bycond <- df4 %>%
  group_by(group) %>%
  summarise(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean) )

df.bysub.bycond <- df4 %>%
  group_by(Gender) %>%
  summarise(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean) )
df.bysub.bycond

df.bysub.bycond <- df3 %>%
  group_by(Speed) %>%
  summarise(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean) )
df.bysub.bycond

df.bysub.bycond <- df3 %>%
  group_by(PatternType) %>%
  summarise(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean) )
df.bysub.bycond

df.bysub.bycond <- df3 %>%
  group_by(Coh) %>%
  summarise(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean) )
df.bysub.bycond
```
```{r acc-logit-4-category, eval=FALSE}
# convert the coherence level in adults and children datasets to be categorical, from 1-4
df_child3<-df_child %>% 
  filter(Group=="linear-radial coh [.15 .3 .45 .6]")
df_child3$Coh_cg <- ordered(factor(df_child3$Coh, 
                 levels = c("1st", "2nd", "3rd", "4th")))
df_adult$Coh_cg <- ordered(factor(df_adult$Coh, 
                 levels = c("1st", "2nd", "3rd", "4th")))
df_all2<-bind_rows(df_child3, df_adult) 
df_all2<- df_all2 %>%
  mutate(group=c(rep('child',nrow(df_child3)),rep('adult',nrow(df_adult))))
df_all2$Speed <- factor(df_all2$Speed, labels = c("2 deg/s", "8 deg/s"))
df_all2$SubID <- factor(df_all2$SubID)
df_all2$group <- factor(df_all2$group)
form.acc.logit<- Acc ~ Gender + Coh + Speed + PatternType + group + group*Coh+group*Speed+ (1|SubID) 
model.acc.logit <- glmer(formula = form.acc.logit, family=binomial(mafc.logit(2)), glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)), data = df_all)
summary(model.acc.logit)
car::Anova(model.acc.logit,type=3)
se <- sqrt(diag(vcov(model.acc.logit)))
# table of estimates with 95% CI
tab <- cbind(OR = fixef(model.acc.logit), LL = fixef(model.acc.logit) - 1.96 * se, UL = fixef(model.acc.logit) + 1.96 * se)
# however, this result is different from the below
print(exp(tab), digits=4)
```
### Plot of actual  *p*(corr) and predicted *p*(corr) by condition
```{r p-corr-pattern-speed-plot-final, include=TRUE}
df_child3 <- df_child %>%
  filter(Group=="linear-radial coh [.15 .3 .45 .6]") %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh)
df_adult2 <- df_adult %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh)
df2<-bind_rows(df_child3, df_adult2) 
df2<- df2 %>%
  mutate(group=c(rep('child',nrow(df_child3)),rep('adult',nrow(df_adult2))))

df2 %>% 
  group_by(SubID, group, PatternType, Coh, Speed) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) -> 
  df.summary
df.summary %>% 
  group_by( group,Coh,Speed,PatternType) %>% 
  summarize(pcorr.mean=mean(Pct.Corr),
         pcorr.sd=sd(Pct.Corr),
         RT.mean.mean=mean(RT.mean),
         RT.mean.sd=sd(RT.mean)) -> 
  df.bygroup.bycond
# add fitted line
xseq<-seq(0.05,0.6,len=100)
df.summary$id<-with(df.summary,interaction(Speed, PatternType, group, SubID))
nd<-data.frame(rep(xseq,8*54),id=rep(levels(df.summary$id),each=100))
# levels(nd$id)<-levels(df.bysub.byage.bycond$id)
mm <-matrix(unlist(strsplit(as.character(nd$id),"[.]")), ncol=4,byrow=TRUE)
nd$Speed<-gsub("[[:space:]]", "",factor(mm[,1]))
nd$PatternType<-factor(mm[,2])
nd$group<-factor(mm[,3])
nd$SubID<-factor(mm[,4])
colnames(nd)[1] <- "Coh"

model.acc.logit.dropgender <- update(model.acc.logit2, . ~ . - Gender)
nd$acc.pred<-predict(model.acc.logit.dropgender,newdata=nd,type="response",se.fit=TRUE) # obtain predicted values
model.fixed.rt.dropgender <- update(model.fixed.rt2, . ~ . - Gender)
nd$rt.pred<-exp(predict(model.fixed.rt.dropgender,newdata=nd, type="response", se.fit=TRUE)) # obtain predicted values

nd2 <- nd %>%
  group_by(group, Speed,Coh, PatternType) %>%
  summarize(acc.pred.mean=mean(acc.pred),
         acc.pred.se=sd(acc.pred)/sqrt(length(acc.pred)),
         RT.pred.mean=mean(rt.pred),
         RT.pred.se=sd(rt.pred)/sqrt(length(rt.pred)))
# df.bygender.bycond$Speed<-factor(df.bygender.bycond$Speed)
```
```{r plot-acc}
# Plot of ectual and predicted ACC
title_text <- 'Percentage of correct responses by Coherence, Pattern, and Speed'
pic.acc<-ggplot(data=df.bygroup.bycond, aes(x=Coh, y=pcorr.mean, color=group)) +
  geom_point(aes(group=group, color=group),size=2) +
  geom_line(data=nd2, aes(x=Coh,y=acc.pred.mean, group=group, color=group),size=1) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence (%)", y="Percentage of Accuracy") +
  ggtitle(title_text) +
  scale_colour_hue(name="participant gender",    #Legend label, use darker colors
                      breaks=c("Female", "Male"),
                      labels=c("Female", "Male"))+
  theme_bw() +
  theme.custom +
  xlim(0.05, 0.6) +
  geom_hline(yintercept=0.5, linetype="dashed")

pic.acc
```

```{r plot-rt}
# Plot of extual and predicted ACC
title_text <- 'Reaction Times by Coherence, Pattern, and Speed'
pic.rt<-ggplot(data=df.bygroup.bycond, aes(x=Coh, y=RT.mean.mean, color=group)) +
  geom_point(aes(group=group, color=group),size=2) +
  geom_line(data=nd2, aes(x=Coh,y=RT.pred.mean, group=group, color=group),size=1) +
  facet_grid(facets = Speed ~ PatternType) +
  labs(x="Coherence (%)", y="Reaction times (s)") +
  ggtitle(title_text) +
  scale_colour_hue(name="group",    #Legend label, use darker colors
                      breaks=c("child", "adult"),
                     labels=c("Child", "Adult"))+
  theme_bw() +
  theme.custom +
  xlim(0.05, 0.6) 

pic.rt
```

```{r plot-acc-speed-group}
df_p2_all_acc_speed_group <- df_all %>% 
  group_by(SubID, Speed, group) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(Speed, group) %>%
  summarize(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.sem = 100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_all_acc_speed_group <- 
  ggplot(data=df_p2_all_acc_speed_group, aes(x=factor(Speed), y=Pct.Corr.mean, fill = factor(group)) ) +
  geom_bar(stat="identity", position = position_dodge(), width = 0.5) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.sem, ymax = Pct.Corr.mean + Pct.Corr.sem), width=.1,position=position_dodge(.5)) +
  ggtitle("Speed X Group Interaction") +
  ylab("Percentage of Accuracy (%)") +
  xlab("Optic flow Speed") +
  coord_cartesian(ylim=c(70,100)) +
  theme_bw() +
  theme.custom + # Position legend in bottom right
  scale_colour_brewer(palette = "Set1")  +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_all_acc_speed_group 
```
```{r plot-acc-pat-group}
df_p2_all_acc_pat_group <- df_all %>% 
  group_by(SubID, PatternType, group) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot)  %>% 
  group_by(PatternType, group) %>%
  summarize(n=length(Pct.Corr),
            Pct.Corr.mean = 100*mean(Pct.Corr, na.rm=TRUE),
            Pct.Corr.sem = 100*sd(Pct.Corr, na.rm=TRUE)/sqrt(length(Pct.Corr)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_all_acc_pat_group <- 
  ggplot(data=df_p2_all_acc_pat_group, aes(x=factor(PatternType), y=Pct.Corr.mean, fill = factor(group)) ) +
  geom_bar(stat="identity", position = position_dodge(), width = 0.5) +
  geom_errorbar(aes(ymin = Pct.Corr.mean - Pct.Corr.sem, ymax = Pct.Corr.mean + Pct.Corr.sem), width=.1,position=position_dodge(.5)) +
  ggtitle("Pattern X Group Interaction") +
  ylab("Percentage of Accuracy (%)") +
  xlab("Optic flow Pattern Type") +
  coord_cartesian(ylim=c(70,100)) +
  theme_bw() +
  theme.custom + # Position legend in bottom right
  scale_colour_brewer(palette = "Set1")  +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_all_acc_pat_group
```














# SDT
```{r get-SDT}
# library(psycho)
# Let's simulate three participants with different results at a perceptual detection task
df_child2 <- df_child %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Response, Age) %>%
   dplyr::filter(Coh==0.15) %>%
   dplyr::filter(Response %in% c("L","R"))
str(df_child2)

df_adult2 <- df_adult %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Response,Age) %>%
   dplyr::filter(Coh==0.15)  %>%
   dplyr::filter(Response %in% c("L","R"))
df_adult2$SubID<-factor(df_adult2$SubID)
str(df_adult2)

df2<-rbind(df_child2, df_adult2) 
df.new<- df2 %>%
  mutate(group=c(rep('child',nrow(df_child2)),rep('adult',nrow(df_adult2)))) %>%
  filter(Response != "NA") %>%
  group_by(SubID, group, Coh, PatternType, Speed, Gender) %>%
  summarize(n_hit = sum(Response=="L" & Acc=="TRUE"),
            n_fa  = sum(Response=="L" & Acc=="FALSE"),
            n_miss = sum(Response=="R" & Acc=="FALSE"),
            n_cr = sum(Response=="R" & Acc=="TRUE"))

indices <- neuropsychology::dprime(df.new$n_hit, df.new$n_fa, df.new$n_miss, df.new$n_cr)
df.sdt <- cbind(df.new, indices)
```

``` {r anova-SDT-d'}
aov <- with(df.sdt, aov(dprime ~ Speed * PatternType * group * Gender +
                       Error(SubID / (Speed * PatternType)))
)
summary(aov)
# better solution I currently find
library(afex)
df.sdt$SubID<-as.integer(df.sdt$SubID) 
a_d <- aov_ez(id="SubID", dv = "dprime", df.sdt, between = c("Gender", "group"),within=c("Speed","PatternType") )
summary(a_d)
knitr::kable(nice(a_d))
# calculate power
library(pwr)
pwr.anova.test(k = 2, n = 50, f = 0.17, sig.level = 0.05, power = NULL)  # for pattern
pwr.anova.test(k = 2, n = 29, f = 0.15, sig.level = 0.05, power = NULL)  # for group
pwr.f2.test(u =27, v = 1, f2 = 34.94, sig.level = 0.05, power = NULL) # age effect in children
## chilren only
df.sdt.c<-df.sdt %>% filter(group=="child")
a_d.c <- aov_ez(id="SubID", dv = "dprime", df.sdt.c, between = c("Gender"),within=c("Speed","PatternType") )
summary(a_d.c)
knitr::kable(nice(a_d.c))
## adults only
df.sdt.a<-df.sdt %>% filter(group=="adult")
a_d.a <- aov_ez(id="SubID", dv = "dprime", df.sdt.a, between = c("Gender"),within=c("Speed","PatternType") )
summary(a_d.a)
knitr::kable(nice(a_d.a))

# What about the estimated marginal means of the design?
library(emmeans)
emmeans(a_d, ~Gender* group * Speed*PatternType)
# What about the ‘main effects?
em1<-emmeans(a_d, ~Gender)
em2<-emmeans(a_d, ~group)
em2<-emmeans(a_d, ~Speed)
em2<-emmeans(a_d, ~PatternType)
em2<-emmeans(a_d, ~Speed*group)
em2<-emmeans(a_d, ~PatternType*group)
em2<-emmeans(a_d, ~Gender*PatternType*group)
# And pairwise difference among levels of inference validity?
em1
pairs(em1)
em2
pairs(em2)
df.sdt %>%
   dplyr::group_by(group) %>%
   summarize(mean=mean(dprime))
```
```{r}
alpha=0.05
data_summary <- function(x) {
   m <- mean(x)
   se=sd(x) / sqrt(length(x))
   t=qt((1-alpha)/2 + .5, length(x)-1)   # tend to 1.96 if sample size is big enough
   CI=t*se
   ymin <- m-CI
   ymax <- m+CI
   return(c(y=m,ymin=ymin,ymax=ymax))
}
ggplot(data = df.sdt, aes(y = dprime, x = Speed,fill=group)) + # Move y and x here so than they can be used in stat_*
    geom_dotplot(aes(fill = group),   # Use fill = Species here not in ggplot()
                 binaxis = "y",         # which axis to bin along
                 binwidth = 0.1,        # Minimal difference considered diffeerent
                 stackdir = "center", # Centered
                 position=position_dodge(0.9)   # separate
                 ) +
    stat_summary(fun.data=data_summary,position=position_dodge(0.9))
```

```{r}
df_p2_c_sdt <- df.sdt %>% 
  group_by(Speed, group) %>% 
  summarize(dmean = mean(dprime, na.rm=TRUE),
            dci = 1.96*sd(dprime, na.rm=TRUE)/sqrt(length(dprime)))  #computation of the standard error of the mean, ci is 1.96*sem
p2_c_sdt_group_speed <- 
  ggplot(data=df_p2_c_sdt, aes(x=Speed, y=dmean, fill = factor(group)) , width = 0.1) +
  geom_bar(stat="identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = dmean - dci, ymax = dmean + dci), width=.1,position=position_dodge(.9)) +
  ggtitle("Speed X Group Interaction (SDT)") +
  xlab("Speed") +
  coord_cartesian(ylim=c(0,2.7)) +
  theme_bw(base_size = 18) +
 # theme.custom + # Position legend in bottom right
  ylab("Mean sensitivity (d')") +
  scale_fill_viridis(discrete=TRUE) +   
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_c_sdt_group_speed
ggsave("C:/Users/yimin/OneDrive/Documents/R/moco-psychophysics/analysis/pub_image/6_sdt_speed_group.pdf", p2_c_sdt_group_speed, width=12, height=10)
```
``` {r anova-SDT-c}
# better solution I currently find
library(afex)
a <- aov_ez(id="SubID", dv = "c", df.sdt, between = c("Gender", "group"),within=c("Speed","PatternType") )
summary(a)
knitr::kable(nice(a))
# What about the estimated marginal means of the design?
library(emmeans)
emmeans(a, ~Gender* group * Speed*PatternType)
knitr::kable(nice(a))
# What about the ‘main effects?
em1<-emmeans(a, ~Gender)
em2<-emmeans(a, ~group)
em2<-emmeans(a, ~Speed)
em2<-emmeans(a, ~PatternType)
em2<-emmeans(a, ~PatternType*Gender)
em3<-emmeans(a, ~group*Speed)
# And pairwise difference among levels of inference validity?
em1
pairs(em1)
em2
pairs(em2)
em3
pairs(em3)
```

```{r anova-plot}
# Plotting results of aov_ez
# emmip(a, Group~ PatternType|Speed, CIs = TRUE)
emmip(a, group~Speed, CIs = TRUE, 
                 legend = TRUE,
              #   trace.label = deparse(substitute(trace.factor)),
                 xlab = "Speed",
                 ylab = "Decision bias")
# the other way to plot barplot
df_all_sdt_speed_group<-as.data.frame(summary(em3))
names(df_all_sdt_speed_group)[1] <- "Group"
df_all_sdt_speed_group$Group <- plyr::revalue(df_all_sdt_speed_group$Group, c("child"="Child", "adult"="Adult"))
df_all_sdt_speed_group$Speed <- plyr::revalue(df_all_sdt_speed_group$Speed, c("X2.deg.s"="Low-speed", "X8.deg.s"="High-speed"))
p1_all_sdt_speed_group <- 
  ggplot(data=df_all_sdt_speed_group, aes(x=factor(Speed), y=emmean, fill = factor(Group)) ) +
  geom_bar(stat="identity", position = position_dodge(), width = 0.5) +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width=.1, position=position_dodge(.5)) +
  ggtitle("Speed X Group Interaction on Decision Criterion") +
  ylab("Decision Criterion") +
  xlab("Optic flow Speed") +
  coord_cartesian(ylim=c(0,0.2)) +
  theme_bw() +
  theme.custom + # Position legend in bottom right
  scale_colour_brewer(palette = "Set1")  +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p1_all_sdt_speed_group


emmip(a, Gender~PatternType, CIs = TRUE)
em4<-emmeans(a, ~Gender*PatternType)
df_all_sdt_gender_patterntype<-as.data.frame(summary(em4))
df_all_sdt_gender_patterntype$PatternType <- plyr::revalue(df_all_sdt_gender_patterntype$PatternType, c("linear"="Linear", "radial"="Radial"))
p2_all_sdt_gender_patterntype <- 
  ggplot(data=df_all_sdt_gender_patterntype, aes(x=factor(PatternType), y=emmean, fill = factor(Gender)) ) +
  geom_bar(stat="identity", position = position_dodge(), width = 0.5) +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width=.1, position=position_dodge(.5)) +
  ggtitle("Pattern X Gender Interaction on Decision Criterion") +
  ylab("Decision Criterion") +
  xlab("Optic flow Pattern") +
  coord_cartesian(ylim=c(0,0.2)) +
  theme_bw() +
  theme.custom + # Position legend in bottom right
  scale_colour_brewer(palette = "Set1")  +
  theme(legend.position=c(0.1,0.9)) +
  theme(plot.title = element_text(hjust = 0.5)) 
p2_all_sdt_gender_patterntype 
```

```{r plot-age-dprime}
library(dplyr)
df_child3 <- df_child %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Response, Age) %>%
   dplyr::filter(Coh==0.15) %>%
   dplyr::filter(Response %in% c("L","R"))
# df_child3$SubID<-factor(df_child3$SubID)

df_adult3 <- df_adult %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Response, Age) %>%
   dplyr::filter(Coh==0.15)  %>%
   dplyr::filter(Response %in% c("L","R"))
# df_adult3$SubID<-factor(df_adult3$SubID)

df3<-rbind(df_child3, df_adult3) 
df.new2<- df3 %>%
  mutate(Group=c(rep('Child',nrow(df_child3)),rep('Adult',nrow(df_adult3)))) %>%
  filter(Response != "NA") %>%
  group_by(SubID, Speed, Age) %>%
  summarise(n_hit = sum(Response=="L" & Acc=="TRUE"),
            n_fa  = sum(Response=="L" & Acc=="FALSE"),
            n_miss = sum(Response=="R" & Acc=="FALSE"),
            n_cr = sum(Response=="R" & Acc=="TRUE") )  

indices2 <- neuropsychology::dprime(df.new2$n_hit, df.new2$n_fa, df.new2$n_miss, df.new2$n_cr)
df.sdt2 <- cbind(df.new2, indices2)

p3_all_d_sdt_speed_age <- ggplot(data =  df.sdt2, 
       aes(y = dprime, x = Age, color = Speed, group = Speed) ) + 
    geom_point() +
    geom_smooth() +
    ggtitle("Speed X Age Interaction") +
    ylab("Sensitivity (d')") +
    xlab("Age") +
 #   coord_cartesian(ylim=c(65,100)) +
    theme_bw() +
    theme.custom + # Position legend in bottom right
    scale_colour_brewer(palette = "Set1")  +
    theme(legend.position=c(0.1,0.9)) +
    theme(plot.title = element_text(hjust = 0.5)) 
p3_all_d_sdt_speed_age 
```

``` {r anova-SDT_child}
df.new_c<- df_child %>%
   dplyr::select(SubID, PatternType, RT, Acc, Speed, Gender, Coh, Response, AgeYrs, Group) %>%
   dplyr::filter(Group == "linear-radial coh [.15 .3 .45 .6]") %>%
   dplyr::filter(Response %in% c("L","R")) 
df.new_c$ Coh<-factor(df.new_c$Coh)
df.new_c<- df.new_c %>%
  group_by(SubID, Coh, PatternType, Speed, Gender, AgeYrs) %>%
  summarize(n_hit = sum(Response=="L" & Acc=="TRUE"),
            n_fa  = sum(Response=="L" & Acc=="FALSE"),
            n_miss = sum(Response=="R" & Acc=="FALSE"),
            n_cr = sum(Response=="R" & Acc=="TRUE"))

indices_c <- neuropsychology::dprime(df.new_c$n_hit, df.new_c$n_fa, df.new_c$n_miss, df.new_c$n_cr)
df.sdt_c <- cbind(df.new_c, indices_c)

a2 <- aov_ez(id="SubID", dv = "dprime", df.sdt_c, between = c("Gender", "AgeYrs"),within=c("Speed","PatternType","Coh") )
summary(a2)
knitr::kable(nice(a2))
# What about the estimated marginal means of the design?
library(emmeans)
emmeans(a2, ~Gender* AgeYrs * Speed*PatternType)
# What about the ‘main effects?
em1<-emmeans(a2, ~Gender)
em2<-emmeans(a2, ~AgeYrs)
em2<-emmeans(a2, ~Speed)
em2<-emmeans(a2, ~PatternType)
# And pairwise difference among levels of inference validity?
em1
pairs(em1)
em2
pairs(em2)
emmip(a2, Speed~AgeYrs|Coh, CIs = TRUE,
                 legend = TRUE,
              #   trace.label = deparse(substitute(trace.factor)),
                 xlab = "Age of Children",
                 ylab = "Sensitivity (d')")
a3 <- aov_ez(id="SubID", dv = "c", df.sdt_c, between = c("Gender", "AgeYrs"),within=c("Speed","PatternType","Coh") )
summary(a3)
```
``` {r anova-plot}
# Plotting results of aov_ez
emmip(a, group ~ PatternType|Speed, CIs = TRUE)
```

``` {r anova-plot}
myData <- aggregate(df.new$dprime,
    by = list(PatternType = df.new$PatternType, Gender = df.new$Gender),
    FUN = function(x) c(mean = mean(x), sd = sd(x),
                        n = length(x)))
myData <- do.call(data.frame, myData)
myData$se <- myData$x.sd / sqrt(myData$x.n)
ggplot(myData, aes(x=PatternType, y=x.mean, group=Gender, fill=Gender)) + 
  geom_bar(stat="identity",  
           position=position_dodge()) +
  geom_errorbar(aes(ymin=x.mean-se, ymax=x.mean+se), width=.2,position=position_dodge(.9))  + 
  labs( y = "Sensitivity (d')")+
   theme_classic()

myData <- aggregate(df.new$dprime,
    by = list(PatternType = df.new$PatternType, Speed = df.new$Speed),
    FUN = function(x) c(mean = mean(x), sd = sd(x),
                        n = length(x)))
myData <- do.call(data.frame, myData)
myData$se <- myData$x.sd / sqrt(myData$x.n)
myData$Speed<-factor(myData$Speed, levels=c("2","8"),labels= c("2 deg/sec","8 deg/sec"))
ggplot(myData, aes(x=PatternType, y=x.mean, group=Speed, fill=Speed)) + 
  geom_bar(stat="identity",  
           position=position_dodge()) +
  geom_errorbar(aes(ymin=x.mean-se, ymax=x.mean+se), width=.2,position=position_dodge(.9))  + 
  labs( y = "Sensitivity (d')")+
   theme_classic()

myData <- aggregate(df.new$c,
    by = list(Speed = df.new$Speed, Gender = df.new$Gender),
    FUN = function(x) c(mean = mean(x), sd = sd(x),
                        n = length(x)))
myData <- do.call(data.frame, myData)
myData$se <- myData$x.sd / sqrt(myData$x.n)
myData$Speed<-factor(myData$Speed, levels=c("2","8"),labels= c("2 deg/sec","8 deg/sec"))
ggplot(myData, aes(x=Speed, y=x.mean, group=Gender, fill=Gender)) + 
  geom_bar(stat="identity",  
           position=position_dodge()) +
  geom_errorbar(aes(ymin=x.mean-se, ymax=x.mean+se), width=.2,position=position_dodge(.9))  + 
  labs( y = "Response bias (c)", x = "Speed")+
   theme_classic()
```

Visual acuity
```{r}
df1<- df_child %>% 
  group_by(SubID, Gender, Age) %>% 
  summarize(N.corr = sum(Acc), 
            N.tot = n(), 
            Pct.Corr = N.corr/N.tot,
            RT.mean=mean(RT, na.rm = T),
            RT.sd=sd(RT, na.rm = T)) 
df_va<-c("10/10","10/12.5","10/10","10/8","10/10","10/12.5","10/10","10/12.5","10/12.5","10/12.5","10/12.5","10/10","10/8","10/10","10/10","10/10","10/16","10/10","10/10","10/8","10/8","10/16","10/20","10/10","NA","10/16")
df<-cbind(df1,df_va)
```
